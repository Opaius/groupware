{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.bun/@tanstack+form-core@1.24.4/node_modules/@tanstack/form-core/dist/esm/utils.js","sources":["file:///C:/Proiect/groupware2/groupware/node_modules/.bun/%40tanstack%2Bform-core%401.24.4/node_modules/%40tanstack/form-core/src/utils.ts"],"sourcesContent":["import { defaultValidationLogic } from './ValidationLogic'\nimport type { ValidationLogicProps } from './ValidationLogic'\nimport type { FieldValidators } from './FieldApi'\nimport type { FormValidators } from './FormApi'\nimport type {\n  GlobalFormValidationError,\n  ValidationCause,\n  ValidationError,\n  ValidationSource,\n} from './types'\n\nexport type UpdaterFn<TInput, TOutput = TInput> = (input: TInput) => TOutput\n\nexport type Updater<TInput, TOutput = TInput> =\n  | TOutput\n  | UpdaterFn<TInput, TOutput>\n\n/**\n * @private\n */\nexport function functionalUpdate<TInput, TOutput = TInput>(\n  updater: Updater<TInput, TOutput>,\n  input: TInput,\n): TOutput {\n  return typeof updater === 'function'\n    ? (updater as UpdaterFn<TInput, TOutput>)(input)\n    : updater\n}\n\n/**\n * Get a value from an object using a path, including dot notation.\n * @private\n */\nexport function getBy(obj: any, path: any) {\n  const pathObj = makePathArray(path)\n  return pathObj.reduce((current: any, pathPart: any) => {\n    if (current === null) return null\n    if (typeof current !== 'undefined') {\n      return current[pathPart]\n    }\n    return undefined\n  }, obj)\n}\n\n/**\n * Set a value on an object using a path, including dot notation.\n * @private\n */\nexport function setBy(obj: any, _path: any, updater: Updater<any>) {\n  const path = makePathArray(_path)\n\n  function doSet(parent?: any): any {\n    if (!path.length) {\n      return functionalUpdate(updater, parent)\n    }\n\n    const key = path.shift()\n\n    if (\n      typeof key === 'string' ||\n      (typeof key === 'number' && !Array.isArray(parent))\n    ) {\n      if (typeof parent === 'object') {\n        if (parent === null) {\n          parent = {}\n        }\n        return {\n          ...parent,\n          [key]: doSet(parent[key]),\n        }\n      }\n      return {\n        [key]: doSet(),\n      }\n    }\n\n    if (Array.isArray(parent) && typeof key === 'number') {\n      const prefix = parent.slice(0, key)\n      return [\n        ...(prefix.length ? prefix : new Array(key)),\n        doSet(parent[key]),\n        ...parent.slice(key + 1),\n      ]\n    }\n    return [...new Array(key), doSet()]\n  }\n\n  return doSet(obj)\n}\n\n/**\n * Delete a field on an object using a path, including dot notation.\n * @private\n */\nexport function deleteBy(obj: any, _path: any) {\n  const path = makePathArray(_path)\n\n  function doDelete(parent: any): any {\n    if (!parent) return\n    if (path.length === 1) {\n      const finalPath = path[0]!\n      if (Array.isArray(parent) && typeof finalPath === 'number') {\n        return parent.filter((_, i) => i !== finalPath)\n      }\n      const { [finalPath]: remove, ...rest } = parent\n      return rest\n    }\n\n    const key = path.shift()\n\n    if (typeof key === 'string') {\n      if (typeof parent === 'object') {\n        return {\n          ...parent,\n          [key]: doDelete(parent[key]),\n        }\n      }\n    }\n\n    if (typeof key === 'number') {\n      if (Array.isArray(parent)) {\n        if (key >= parent.length) {\n          return parent\n        }\n        const prefix = parent.slice(0, key)\n        return [\n          ...(prefix.length ? prefix : new Array(key)),\n          doDelete(parent[key]),\n          ...parent.slice(key + 1),\n        ]\n      }\n    }\n\n    throw new Error('It seems we have created an infinite loop in deleteBy. ')\n  }\n\n  return doDelete(obj)\n}\n\nconst reLineOfOnlyDigits = /^(\\d+)$/gm\n// the second dot must be in a lookahead or the engine\n// will skip subsequent numbers (like foo.0.1.)\nconst reDigitsBetweenDots = /\\.(\\d+)(?=\\.)/gm\nconst reStartWithDigitThenDot = /^(\\d+)\\./gm\nconst reDotWithDigitsToEnd = /\\.(\\d+$)/gm\nconst reMultipleDots = /\\.{2,}/gm\n\nconst intPrefix = '__int__'\nconst intReplace = `${intPrefix}$1`\n\n/**\n * @private\n */\nexport function makePathArray(str: string | Array<string | number>) {\n  if (Array.isArray(str)) {\n    return [...str]\n  }\n\n  if (typeof str !== 'string') {\n    throw new Error('Path must be a string.')\n  }\n\n  return (\n    str\n      // Leading `[` may lead to wrong parsing down the line\n      // (Example: '[0][1]' should be '0.1', not '.0.1')\n      .replace(/(^\\[)|]/gm, '')\n      .replace(/\\[/g, '.')\n      .replace(reLineOfOnlyDigits, intReplace)\n      .replace(reDigitsBetweenDots, `.${intReplace}.`)\n      .replace(reStartWithDigitThenDot, `${intReplace}.`)\n      .replace(reDotWithDigitsToEnd, `.${intReplace}`)\n      .replace(reMultipleDots, '.')\n      .split('.')\n      .map((d) => {\n        if (d.startsWith(intPrefix)) {\n          const numStr = d.substring(intPrefix.length)\n          const num = parseInt(numStr, 10)\n\n          if (String(num) === numStr) {\n            return num\n          }\n          return numStr\n        }\n        return d\n      })\n  )\n}\n\n/**\n * @private\n */\nexport function concatenatePaths(path1: string, path2: string): string {\n  if (path1.length === 0) return path2\n  if (path2.length === 0) return path1\n\n  if (path2.startsWith('[')) {\n    return path1 + path2\n  }\n\n  // In cases where parent and child withFieldGroup forms are both nested\n  if (path2.startsWith('.')) {\n    return path1 + path2\n  }\n\n  return `${path1}.${path2}`\n}\n\n/**\n * @private\n */\nexport function isNonEmptyArray(obj: any) {\n  return !(Array.isArray(obj) && obj.length === 0)\n}\n\ninterface AsyncValidatorArrayPartialOptions<T> {\n  validators?: T\n  asyncDebounceMs?: number\n}\n\n/**\n * @private\n */\nexport interface AsyncValidator<T> {\n  cause: ValidationCause\n  validate: T\n  debounceMs: number\n}\n\ninterface SyncValidatorArrayPartialOptions<T> {\n  validators?: T\n}\n\n/**\n * @private\n */\nexport interface SyncValidator<T> {\n  cause: ValidationCause\n  validate: T\n}\n\n/**\n * @private\n */\nexport function getSyncValidatorArray<T>(\n  cause: ValidationCause,\n  options: SyncValidatorArrayPartialOptions<T> & {\n    validationLogic?: any\n    form?: any\n  },\n): T extends FieldValidators<\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any\n>\n  ? Array<\n      SyncValidator<\n        | T['onChange']\n        | T['onBlur']\n        | T['onSubmit']\n        | T['onMount']\n        | T['onDynamic']\n      >\n    >\n  : T extends FormValidators<any, any, any, any, any, any, any, any, any, any>\n    ? Array<\n        SyncValidator<\n          | T['onChange']\n          | T['onBlur']\n          | T['onSubmit']\n          | T['onMount']\n          | T['onDynamic']\n        >\n      >\n    : never {\n  const runValidation = (\n    props: Parameters<ValidationLogicProps['runValidation']>[0],\n  ) => {\n    return props.validators.filter(Boolean).map((validator) => {\n      return {\n        cause: validator!.cause,\n        validate: validator!.fn,\n      }\n    })\n  }\n\n  return options.validationLogic({\n    form: options.form,\n    validators: options.validators,\n    event: { type: cause, async: false },\n    runValidation,\n  })\n}\n\n/**\n * @private\n */\nexport function getAsyncValidatorArray<T>(\n  cause: ValidationCause,\n  options: AsyncValidatorArrayPartialOptions<T> & {\n    validationLogic?: any\n    form?: any\n  },\n): T extends FieldValidators<\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any\n>\n  ? Array<\n      AsyncValidator<\n        | T['onChangeAsync']\n        | T['onBlurAsync']\n        | T['onSubmitAsync']\n        | T['onDynamicAsync']\n      >\n    >\n  : T extends FormValidators<any, any, any, any, any, any, any, any, any, any>\n    ? Array<\n        AsyncValidator<\n          | T['onChangeAsync']\n          | T['onBlurAsync']\n          | T['onSubmitAsync']\n          | T['onDynamicAsync']\n        >\n      >\n    : never {\n  const { asyncDebounceMs } = options\n  const {\n    onBlurAsyncDebounceMs,\n    onChangeAsyncDebounceMs,\n    onDynamicAsyncDebounceMs,\n  } = (options.validators || {}) as\n    | FieldValidators<\n        any,\n        any,\n        any,\n        any,\n        any,\n        any,\n        any,\n        any,\n        any,\n        any,\n        any,\n        any\n      >\n    | FormValidators<any, any, any, any, any, any, any, any, any, any>\n\n  const defaultDebounceMs = asyncDebounceMs ?? 0\n\n  const runValidation = (\n    props: Parameters<ValidationLogicProps['runValidation']>[0],\n  ) => {\n    return props.validators.filter(Boolean).map((validator) => {\n      const validatorCause = validator?.cause || cause\n\n      let debounceMs = defaultDebounceMs\n\n      switch (validatorCause) {\n        case 'change':\n          debounceMs = onChangeAsyncDebounceMs ?? defaultDebounceMs\n          break\n        case 'blur':\n          debounceMs = onBlurAsyncDebounceMs ?? defaultDebounceMs\n          break\n        case 'dynamic':\n          debounceMs = onDynamicAsyncDebounceMs ?? defaultDebounceMs\n          break\n        case 'submit':\n          debounceMs = 0 // submit validators are always run immediately\n          break\n        default:\n          break\n      }\n\n      if (cause === 'submit') {\n        debounceMs = 0\n      }\n\n      return {\n        cause: validatorCause,\n        validate: validator!.fn,\n        debounceMs: debounceMs,\n      }\n    })\n  }\n\n  return options.validationLogic({\n    form: options.form,\n    validators: options.validators,\n    event: { type: cause, async: true },\n    runValidation,\n  })\n}\n\nexport const isGlobalFormValidationError = (\n  error: unknown,\n): error is GlobalFormValidationError<unknown> => {\n  return !!error && typeof error === 'object' && 'fields' in error\n}\n\nexport function evaluate<T>(objA: T, objB: T) {\n  if (Object.is(objA, objB)) {\n    return true\n  }\n\n  if (\n    typeof objA !== 'object' ||\n    objA === null ||\n    typeof objB !== 'object' ||\n    objB === null\n  ) {\n    return false\n  }\n\n  if (objA instanceof Date && objB instanceof Date) {\n    return objA.getTime() === objB.getTime()\n  }\n\n  if (objA instanceof Map && objB instanceof Map) {\n    if (objA.size !== objB.size) return false\n    for (const [k, v] of objA) {\n      if (!objB.has(k) || !Object.is(v, objB.get(k))) return false\n    }\n    return true\n  }\n\n  if (objA instanceof Set && objB instanceof Set) {\n    if (objA.size !== objB.size) return false\n    for (const v of objA) {\n      if (!objB.has(v)) return false\n    }\n    return true\n  }\n\n  const keysA = Object.keys(objA)\n  const keysB = Object.keys(objB)\n\n  if (keysA.length !== keysB.length) {\n    return false\n  }\n\n  for (const key of keysA) {\n    // performs recursive search down the object tree\n\n    if (\n      !keysB.includes(key) ||\n      !evaluate(objA[key as keyof T], objB[key as keyof T])\n    ) {\n      return false\n    }\n  }\n\n  return true\n}\n\n/**\n * Determines the logic for determining the error source and value to set on the field meta within the form level sync/async validation.\n * @private\n */\nexport const determineFormLevelErrorSourceAndValue = ({\n  newFormValidatorError,\n  isPreviousErrorFromFormValidator,\n  previousErrorValue,\n}: {\n  newFormValidatorError: ValidationError\n  isPreviousErrorFromFormValidator: boolean\n  previousErrorValue: ValidationError\n}): {\n  newErrorValue: ValidationError\n  newSource: ValidationSource | undefined\n} => {\n  // All falsy values are not considered errors\n  if (newFormValidatorError) {\n    return { newErrorValue: newFormValidatorError, newSource: 'form' }\n  }\n\n  // Clears form level error since it's now stale\n  if (isPreviousErrorFromFormValidator) {\n    return { newErrorValue: undefined, newSource: undefined }\n  }\n\n  // At this point, we have a preivous error which must have been set by the field validator, keep as is\n  if (previousErrorValue) {\n    return { newErrorValue: previousErrorValue, newSource: 'field' }\n  }\n\n  // No new or previous error, clear the error\n  return { newErrorValue: undefined, newSource: undefined }\n}\n\n/**\n * Determines the logic for determining the error source and value to set on the field meta within the field level sync/async validation.\n * @private\n */\nexport const determineFieldLevelErrorSourceAndValue = ({\n  formLevelError,\n  fieldLevelError,\n}: {\n  formLevelError: ValidationError\n  fieldLevelError: ValidationError\n}): {\n  newErrorValue: ValidationError\n  newSource: ValidationSource | undefined\n} => {\n  // At field level, we prioritize the field level error\n  if (fieldLevelError) {\n    return { newErrorValue: fieldLevelError, newSource: 'field' }\n  }\n\n  // If there is no field level error, and there is a form level error, we set the form level error\n  if (formLevelError) {\n    return { newErrorValue: formLevelError, newSource: 'form' }\n  }\n\n  return { newErrorValue: undefined, newSource: undefined }\n}\n\nexport function createFieldMap<T>(values: Readonly<T>): { [K in keyof T]: K } {\n  const output: { [K in keyof T]: K } = {} as any\n\n  for (const key in values) {\n    output[key] = key\n  }\n\n  return output\n}\n\n/**\n * Merge the first parameter with the given overrides.\n * @private\n */\nexport function mergeOpts<T>(\n  originalOpts: T | undefined | null,\n  overrides: T,\n): T {\n  if (originalOpts === undefined || originalOpts === null) {\n    return overrides\n  }\n\n  return { ...originalOpts, ...overrides }\n}\n\n/*\n/ credit is due to https://github.com/lukeed/uuid for this code, with current npm\n/ attacks we didn't feel comfortable installing directly from npm. But big appreciation\n/ from the TanStack Form team <3.\n*/\n\nlet IDX = 256\nconst HEX: string[] = []\nlet BUFFER: number[] | undefined\n\nwhile (IDX--) {\n  HEX[IDX] = (IDX + 256).toString(16).substring(1)\n}\n\nexport function uuid(): string {\n  let i = 0\n  let num: number\n  let out = ''\n\n  if (!BUFFER || IDX + 16 > 256) {\n    BUFFER = new Array<number>(256)\n    i = 256\n    while (i--) {\n      BUFFER[i] = (256 * Math.random()) | 0\n    }\n    i = 0\n    IDX = 0\n  }\n\n  for (; i < 16; i++) {\n    num = BUFFER[IDX + i] as number\n    if (i === 6) out += HEX[(num & 15) | 64]\n    else if (i === 8) out += HEX[(num & 63) | 128]\n    else out += HEX[num]\n\n    if (i & 1 && i > 1 && i < 11) out += '-'\n  }\n\n  IDX++\n  return out\n}\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 362, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.bun/@tanstack+form-core@1.24.4/node_modules/@tanstack/form-core/dist/esm/ValidationLogic.js","sources":["file:///C:/Proiect/groupware2/groupware/node_modules/.bun/%40tanstack%2Bform-core%401.24.4/node_modules/%40tanstack/form-core/src/ValidationLogic.ts"],"sourcesContent":["import type { AnyFormApi, FormValidators } from './FormApi'\n\ninterface ValidationLogicValidatorsFn {\n  // TODO: Type this properly\n  fn: FormValidators<\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any\n  >[keyof FormValidators<any, any, any, any, any, any, any, any, any, any>]\n  cause: 'change' | 'blur' | 'submit' | 'mount' | 'server' | 'dynamic'\n}\n\nexport interface ValidationLogicProps {\n  // TODO: Type this properly\n  form: AnyFormApi\n  // TODO: Type this properly\n  validators:\n    | FormValidators<any, any, any, any, any, any, any, any, any, any>\n    | undefined\n    | null\n  event: {\n    type: 'blur' | 'change' | 'submit' | 'mount' | 'server'\n    fieldName?: string\n    async: boolean\n  }\n  runValidation: (props: {\n    validators: Array<ValidationLogicValidatorsFn | undefined>\n    form: AnyFormApi\n  }) => void\n}\n\ninterface RevalidateLogicProps {\n  /**\n   * @default 'submit'\n   *\n   * This is the mode that will be used before the form has been submitted.\n   * It will run the validation logic on `submit` by default, but can be set to `change` or `blur`.\n   */\n  mode?: 'change' | 'blur' | 'submit'\n  /**\n   * @default 'change'\n   *\n   * This is the mode that will be used after the form has been submitted.\n   * It will run the validation logic on `change` by default, but can be set to `blur` or `submit`.\n   */\n  modeAfterSubmission?: 'change' | 'blur' | 'submit'\n}\n\nexport type ValidationLogicFn = (props: ValidationLogicProps) => void\n\n/**\n * This forces a form's validation logic to be ran as if it were a React Hook Form validation logic.\n *\n * This means that it will only run the `onDynamic` validator, and it will not run any other validators and changes the validation\n * type based on the state of the form itself.\n *\n * When the form is not yet submitted, it will not run the validation logic.\n * When the form is submitted, it will run the validation logic on `change`\n */\nexport const revalidateLogic =\n  ({\n    mode = 'submit',\n    modeAfterSubmission = 'change',\n  }: RevalidateLogicProps = {}): ValidationLogicFn =>\n  (props) => {\n    const validatorNames = Object.keys(props.validators ?? {})\n    if (validatorNames.length === 0) {\n      // No validators is a valid case, just return\n      return props.runValidation({\n        validators: [],\n        form: props.form,\n      })\n    }\n\n    const dynamicValidator = {\n      fn: props.event.async\n        ? props.validators!['onDynamicAsync']\n        : props.validators!['onDynamic'],\n      cause: 'dynamic',\n    } as const\n\n    const validatorsToAdd = [] as ValidationLogicValidatorsFn[]\n\n    const modeToWatch =\n      props.form.state.submissionAttempts === 0 ? mode : modeAfterSubmission\n\n    if ([modeToWatch, 'submit'].includes(props.event.type)) {\n      validatorsToAdd.push(dynamicValidator)\n    }\n\n    let defaultValidators = [] as ValidationLogicValidatorsFn[]\n\n    defaultValidationLogic({\n      ...props,\n      runValidation: (vProps) => {\n        defaultValidators = vProps.validators as ValidationLogicValidatorsFn[]\n      },\n    })\n\n    if (validatorsToAdd.length === 0) {\n      return props.runValidation({\n        validators: defaultValidators,\n        form: props.form,\n      })\n    }\n\n    return props.runValidation({\n      validators: [...defaultValidators, ...validatorsToAdd],\n      form: props.form,\n    })\n  }\n\nexport const defaultValidationLogic: ValidationLogicFn = (props) => {\n  // Handle case where no validators are provided\n  if (!props.validators) {\n    return props.runValidation({\n      validators: [],\n      form: props.form,\n    })\n  }\n\n  const isAsync = props.event.async\n\n  const onMountValidator = isAsync\n    ? undefined\n    : ({ fn: props.validators.onMount, cause: 'mount' } as const)\n\n  const onChangeValidator = {\n    fn: isAsync ? props.validators.onChangeAsync : props.validators.onChange,\n    cause: 'change',\n  } as const\n\n  const onBlurValidator = {\n    fn: isAsync ? props.validators.onBlurAsync : props.validators.onBlur,\n    cause: 'blur',\n  } as const\n\n  const onSubmitValidator = {\n    fn: isAsync ? props.validators.onSubmitAsync : props.validators.onSubmit,\n    cause: 'submit',\n  } as const\n\n  // Allows us to clear onServer errors\n  const onServerValidator = isAsync\n    ? undefined\n    : ({ fn: () => undefined, cause: 'server' } as const)\n\n  switch (props.event.type) {\n    case 'mount': {\n      // Run mount validation\n      return props.runValidation({\n        validators: [onMountValidator],\n        form: props.form,\n      })\n    }\n    case 'submit': {\n      // Run change, blur, submit, server validation\n      return props.runValidation({\n        validators: [\n          onChangeValidator,\n          onBlurValidator,\n          onSubmitValidator,\n          onServerValidator,\n        ],\n        form: props.form,\n      })\n    }\n    case 'server': {\n      // Run server validation\n      return props.runValidation({\n        validators: [],\n        form: props.form,\n      })\n    }\n    case 'blur': {\n      // Run blur, server validation\n      return props.runValidation({\n        validators: [onBlurValidator, onServerValidator],\n        form: props.form,\n      })\n    }\n    case 'change': {\n      // Run change, server validation\n      return props.runValidation({\n        validators: [onChangeValidator, onServerValidator],\n        form: props.form,\n      })\n    }\n    default: {\n      throw new Error(`Unknown validation event type: ${props.event.type}`)\n    }\n  }\n}\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 502, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.bun/@tanstack+form-core@1.24.4/node_modules/@tanstack/form-core/dist/esm/standardSchemaValidator.js","sources":["file:///C:/Proiect/groupware2/groupware/node_modules/.bun/%40tanstack%2Bform-core%401.24.4/node_modules/%40tanstack/form-core/src/standardSchemaValidator.ts"],"sourcesContent":["import type { ValidationSource } from './types'\n\nexport type TStandardSchemaValidatorValue<\n  TData,\n  TSource extends ValidationSource = ValidationSource,\n> = {\n  value: TData\n  validationSource: TSource\n}\n\nexport type TStandardSchemaValidatorIssue<\n  TSource extends ValidationSource = ValidationSource,\n> = TSource extends 'form'\n  ? {\n      form: Record<string, StandardSchemaV1Issue[]>\n      fields: Record<string, StandardSchemaV1Issue[]>\n    }\n  : TSource extends 'field'\n    ? StandardSchemaV1Issue[]\n    : never\n\nfunction prefixSchemaToErrors(\n  issues: readonly StandardSchemaV1Issue[],\n  formValue: unknown,\n) {\n  const schema = new Map<string, StandardSchemaV1Issue[]>()\n\n  for (const issue of issues) {\n    const issuePath = issue.path ?? []\n\n    let currentFormValue = formValue\n    let path = ''\n\n    for (let i = 0; i < issuePath.length; i++) {\n      const pathSegment = issuePath[i]\n      if (pathSegment === undefined) continue\n\n      const segment =\n        typeof pathSegment === 'object' ? pathSegment.key : pathSegment\n\n      // Standard Schema doesn't specify if paths should use numbers or stringified numbers for array access.\n      // However, if we follow the path it provides and encounter an array, then we can assume it's intended for array access.\n      const segmentAsNumber = Number(segment)\n      if (Array.isArray(currentFormValue) && !Number.isNaN(segmentAsNumber)) {\n        path += `[${segmentAsNumber}]`\n      } else {\n        path += (i > 0 ? '.' : '') + String(segment)\n      }\n\n      if (typeof currentFormValue === 'object' && currentFormValue !== null) {\n        currentFormValue = currentFormValue[segment as never]\n      } else {\n        currentFormValue = undefined\n      }\n    }\n    schema.set(path, (schema.get(path) ?? []).concat(issue))\n  }\n\n  return Object.fromEntries(schema)\n}\n\nconst transformFormIssues = <TSource extends ValidationSource>(\n  issues: readonly StandardSchemaV1Issue[],\n  formValue: unknown,\n): TStandardSchemaValidatorIssue<TSource> => {\n  const schemaErrors = prefixSchemaToErrors(issues, formValue)\n  return {\n    form: schemaErrors,\n    fields: schemaErrors,\n  } as TStandardSchemaValidatorIssue<TSource>\n}\n\nexport const standardSchemaValidators = {\n  validate<TSource extends ValidationSource = ValidationSource>(\n    {\n      value,\n      validationSource,\n    }: TStandardSchemaValidatorValue<unknown, TSource>,\n    schema: StandardSchemaV1,\n  ): TStandardSchemaValidatorIssue<TSource> | undefined {\n    const result = schema['~standard'].validate(value)\n\n    if (result instanceof Promise) {\n      throw new Error('async function passed to sync validator')\n    }\n\n    if (!result.issues) return\n\n    if (validationSource === 'field')\n      return result.issues as TStandardSchemaValidatorIssue<TSource>\n    return transformFormIssues<TSource>(result.issues, value)\n  },\n  async validateAsync<TSource extends ValidationSource>(\n    {\n      value,\n      validationSource,\n    }: TStandardSchemaValidatorValue<unknown, TSource>,\n    schema: StandardSchemaV1,\n  ): Promise<TStandardSchemaValidatorIssue<TSource> | undefined> {\n    const result = await schema['~standard'].validate(value)\n\n    if (!result.issues) return\n\n    if (validationSource === 'field')\n      return result.issues as TStandardSchemaValidatorIssue<TSource>\n    return transformFormIssues<TSource>(result.issues, value)\n  },\n}\n\nexport const isStandardSchemaValidator = (\n  validator: unknown,\n): validator is StandardSchemaV1 =>\n  !!validator && '~standard' in (validator as object)\n\n/**\n * The Standard Schema interface.\n */\nexport type StandardSchemaV1<Input = unknown, Output = Input> = {\n  /**\n   * The Standard Schema properties.\n   */\n  readonly '~standard': StandardSchemaV1Props<Input, Output>\n}\n\n/**\n * The Standard Schema properties interface.\n */\ninterface StandardSchemaV1Props<Input = unknown, Output = Input> {\n  /**\n   * The version number of the standard.\n   */\n  readonly version: 1\n  /**\n   * The vendor name of the schema library.\n   */\n  readonly vendor: string\n  /**\n   * Validates unknown input values.\n   */\n  readonly validate: (\n    value: unknown,\n  ) => StandardSchemaV1Result<Output> | Promise<StandardSchemaV1Result<Output>>\n  /**\n   * Inferred types associated with the schema.\n   */\n  readonly types?: StandardSchemaV1Types<Input, Output> | undefined\n}\n/**\n * The result interface of the validate function.\n */\ntype StandardSchemaV1Result<Output> =\n  | StandardSchemaV1SuccessResult<Output>\n  | StandardSchemaV1FailureResult\n/**\n * The result interface if validation succeeds.\n */\ninterface StandardSchemaV1SuccessResult<Output> {\n  /**\n   * The typed output value.\n   */\n  readonly value: Output\n  /**\n   * The non-existent issues.\n   */\n  readonly issues?: undefined\n}\n/**\n * The result interface if validation fails.\n */\ninterface StandardSchemaV1FailureResult {\n  /**\n   * The issues of failed validation.\n   */\n  readonly issues: ReadonlyArray<StandardSchemaV1Issue>\n}\n/**\n * The issue interface of the failure output.\n */\nexport interface StandardSchemaV1Issue {\n  /**\n   * The error message of the issue.\n   */\n  readonly message: string\n  /**\n   * The path of the issue, if any.\n   */\n  readonly path?:\n    | ReadonlyArray<PropertyKey | StandardSchemaV1PathSegment>\n    | undefined\n}\n/**\n * The path segment interface of the issue.\n */\ninterface StandardSchemaV1PathSegment {\n  /**\n   * The key representing a path segment.\n   */\n  readonly key: PropertyKey\n}\n/**\n * The Standard Schema types interface.\n */\ninterface StandardSchemaV1Types<Input = unknown, Output = Input> {\n  /**\n   * The input type of the schema.\n   */\n  readonly input: Input\n  /**\n   * The output type of the schema.\n   */\n  readonly output: Output\n}\n"],"names":[],"mappings":";;;;;;AAqBA,SAAS,qBACP,MAAA,EACA,SAAA,EACA;IACA,MAAM,SAAA,aAAA,GAAA,IAAa,IAAA;IAEnB,KAAA,MAAW,SAAS,OAAQ;;QAC1B,MAAM,iCAAkB,IAAA,uCAAN,cAAc,CAAA,CAAA;QAEhC,IAAI,mBAAmB;QACvB,IAAI,OAAO;QAEX,IAAA,IAAS,IAAI,GAAG,IAAI,UAAU,MAAA,EAAQ,IAAK;YACzC,MAAM,cAAc,SAAA,CAAU,CAAC,CAAA;YAC/B,IAAI,gBAAgB,KAAA,EAAW,CAAA;YAE/B,MAAM,UACJ,OAAO,gBAAgB,WAAW,YAAY,GAAA,GAAM;YAItD,MAAM,kBAAkB,OAAO,OAAO;YACtC,IAAI,MAAM,OAAA,CAAQ,gBAAgB,KAAK,CAAC,OAAO,KAAA,CAAM,eAAe,GAAG;gBACrE,QAAQ,IAAmB,OAAf,eAAe,EAAA;YAC7B,OAAO;gBACL,QAAA,CAAS,IAAI,IAAI,MAAM,EAAA,IAAM,OAAO,OAAO;YAC7C;YAEA,IAAI,OAAO,qBAAqB,YAAY,qBAAqB,MAAM;gBACrE,mBAAmB,gBAAA,CAAiB,OAAgB,CAAA;YACtD,OAAO;gBACL,mBAAmB,KAAA;YACrB;QACF;YACkB;QAAlB,OAAO,GAAA,CAAI,MAAA,uBAAc,GAAA,CAAI,IAAI,sDAAK,CAAA,CAAA,EAAI,MAAA,CAAO,KAAK,CAAC;IACzD;IAEA,OAAO,OAAO,WAAA,CAAY,MAAM;AAClC;AAEA,MAAM,sBAAsB,CAC1B,QACA,cAC2C;IAC3C,MAAM,eAAe,qBAAqB,QAAQ,SAAS;IAC3D,OAAO;QACL,MAAM;QACN,QAAQ;IAAA;AAEZ;AAEO,MAAM,2BAA2B;IACtC,eAGI,EAEF,MAAA,EACoD;cAJlD,KAAA,EACA,gBAAA,EAAA,GAFF;QAMA,MAAM,SAAS,MAAA,CAAO,WAAW,CAAA,CAAE,QAAA,CAAS,KAAK;QAEjD,IAAI,kBAAkB,SAAS;YAC7B,MAAM,IAAI,MAAM,yCAAyC;QAC3D;QAEA,IAAI,CAAC,OAAO,MAAA,CAAQ,CAAA;QAEpB,IAAI,qBAAqB,SACvB,OAAO,OAAO,MAAA;QAChB,OAAO,oBAA6B,OAAO,MAAA,EAAQ,KAAK;IAC1D;IACA,MAAM,oBAGF,EAEF,MAAA,EAC6D;cAJ3D,KAAA,EACA,gBAAA,EAAA,GAFF;QAMA,MAAM,SAAS,MAAM,MAAA,CAAO,WAAW,CAAA,CAAE,QAAA,CAAS,KAAK;QAEvD,IAAI,CAAC,OAAO,MAAA,CAAQ,CAAA;QAEpB,IAAI,qBAAqB,SACvB,OAAO,OAAO,MAAA;QAChB,OAAO,oBAA6B,OAAO,MAAA,EAAQ,KAAK;IAC1D;AACF;AAEO,MAAM,4BAA4B,CACvC,YAEA,CAAC,CAAC,aAAa,eAAgB","debugId":null}},
    {"offset": {"line": 569, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.bun/@tanstack+form-core@1.24.4/node_modules/@tanstack/form-core/dist/esm/metaHelper.js","sources":["file:///C:/Proiect/groupware2/groupware/node_modules/.bun/%40tanstack%2Bform-core%401.24.4/node_modules/%40tanstack/form-core/src/metaHelper.ts"],"sourcesContent":["import type {\n  FormApi,\n  FormAsyncValidateOrFn,\n  FormValidateOrFn,\n} from './FormApi'\nimport type { AnyFieldMeta } from './FieldApi'\nimport type { DeepKeys } from './util-types'\n\ntype ArrayFieldMode = 'insert' | 'remove' | 'swap' | 'move'\n\nexport const defaultFieldMeta: AnyFieldMeta = {\n  isValidating: false,\n  isTouched: false,\n  isBlurred: false,\n  isDirty: false,\n  isPristine: true,\n  isValid: true,\n  isDefaultValue: true,\n  errors: [],\n  errorMap: {},\n  errorSourceMap: {},\n}\n\nexport function metaHelper<\n  TFormData,\n  TOnMount extends undefined | FormValidateOrFn<TFormData>,\n  TOnChange extends undefined | FormValidateOrFn<TFormData>,\n  TOnChangeAsync extends undefined | FormAsyncValidateOrFn<TFormData>,\n  TOnBlur extends undefined | FormValidateOrFn<TFormData>,\n  TOnBlurAsync extends undefined | FormAsyncValidateOrFn<TFormData>,\n  TOnSubmit extends undefined | FormValidateOrFn<TFormData>,\n  TOnSubmitAsync extends undefined | FormAsyncValidateOrFn<TFormData>,\n  TOnDynamic extends undefined | FormValidateOrFn<TFormData>,\n  TOnDynamicAsync extends undefined | FormAsyncValidateOrFn<TFormData>,\n  TOnServer extends undefined | FormAsyncValidateOrFn<TFormData>,\n  TSubmitMeta,\n>(\n  formApi: FormApi<\n    TFormData,\n    TOnMount,\n    TOnChange,\n    TOnChangeAsync,\n    TOnBlur,\n    TOnBlurAsync,\n    TOnSubmit,\n    TOnSubmitAsync,\n    TOnDynamic,\n    TOnDynamicAsync,\n    TOnServer,\n    TSubmitMeta\n  >,\n) {\n  function handleArrayFieldMetaShift(\n    field: DeepKeys<TFormData>,\n    index: number,\n    mode: ArrayFieldMode,\n    secondIndex?: number,\n  ) {\n    const affectedFields = getAffectedFields(field, index, mode, secondIndex)\n\n    const handlers = {\n      insert: () => handleInsertMode(affectedFields, field, index),\n      remove: () => handleRemoveMode(affectedFields),\n      swap: () =>\n        secondIndex !== undefined &&\n        handleSwapMode(affectedFields, field, index, secondIndex),\n      move: () =>\n        secondIndex !== undefined &&\n        handleMoveMode(affectedFields, field, index, secondIndex),\n    }\n\n    handlers[mode]()\n  }\n\n  function getFieldPath(field: DeepKeys<TFormData>, index: number): string {\n    return `${field}[${index}]`\n  }\n\n  function getAffectedFields(\n    field: DeepKeys<TFormData>,\n    index: number,\n    mode: ArrayFieldMode,\n    secondIndex?: number,\n  ): DeepKeys<TFormData>[] {\n    const affectedFieldKeys = [getFieldPath(field, index)]\n\n    if (mode === 'swap') {\n      affectedFieldKeys.push(getFieldPath(field, secondIndex!))\n    } else if (mode === 'move') {\n      const [startIndex, endIndex] = [\n        Math.min(index, secondIndex!),\n        Math.max(index, secondIndex!),\n      ]\n      for (let i = startIndex; i <= endIndex; i++) {\n        affectedFieldKeys.push(getFieldPath(field, i))\n      }\n    } else {\n      const currentValue = formApi.getFieldValue(field)\n      const fieldItems = Array.isArray(currentValue)\n        ? (currentValue as Array<unknown>).length\n        : 0\n      for (let i = index + 1; i < fieldItems; i++) {\n        affectedFieldKeys.push(getFieldPath(field, i))\n      }\n    }\n\n    return Object.keys(formApi.fieldInfo).filter((fieldKey) =>\n      affectedFieldKeys.some((key) => fieldKey.startsWith(key)),\n    ) as DeepKeys<TFormData>[]\n  }\n\n  function updateIndex(\n    fieldKey: string,\n    direction: 'up' | 'down',\n  ): DeepKeys<TFormData> {\n    return fieldKey.replace(/\\[(\\d+)\\]/, (_, num) => {\n      const currIndex = parseInt(num, 10)\n      const newIndex =\n        direction === 'up' ? currIndex + 1 : Math.max(0, currIndex - 1)\n      return `[${newIndex}]`\n    }) as DeepKeys<TFormData>\n  }\n\n  function shiftMeta(fields: DeepKeys<TFormData>[], direction: 'up' | 'down') {\n    const sortedFields = direction === 'up' ? fields : [...fields].reverse()\n\n    sortedFields.forEach((fieldKey) => {\n      const nextFieldKey = updateIndex(fieldKey.toString(), direction)\n      const nextFieldMeta = formApi.getFieldMeta(nextFieldKey)\n      if (nextFieldMeta) {\n        formApi.setFieldMeta(fieldKey, nextFieldMeta)\n      } else {\n        formApi.setFieldMeta(fieldKey, getEmptyFieldMeta())\n      }\n    })\n  }\n\n  const getEmptyFieldMeta = (): AnyFieldMeta => defaultFieldMeta\n\n  const handleInsertMode = (\n    fields: DeepKeys<TFormData>[],\n    field: DeepKeys<TFormData>,\n    insertIndex: number,\n  ) => {\n    shiftMeta(fields, 'down')\n\n    fields.forEach((fieldKey) => {\n      if (fieldKey.toString().startsWith(getFieldPath(field, insertIndex))) {\n        formApi.setFieldMeta(fieldKey, getEmptyFieldMeta())\n      }\n    })\n  }\n\n  const handleRemoveMode = (fields: DeepKeys<TFormData>[]) => {\n    shiftMeta(fields, 'up')\n  }\n\n  const handleMoveMode = (\n    fields: DeepKeys<TFormData>[],\n    field: DeepKeys<TFormData>,\n    fromIndex: number,\n    toIndex: number,\n  ) => {\n    // Store the original field meta that will be reapplied at the destination index\n    const fromFields = new Map(\n      Object.keys(formApi.fieldInfo)\n        .filter((fieldKey) =>\n          fieldKey.startsWith(getFieldPath(field, fromIndex)),\n        )\n        .map((fieldKey) => [\n          fieldKey as DeepKeys<TFormData>,\n          formApi.getFieldMeta(fieldKey as DeepKeys<TFormData>),\n        ]),\n    )\n\n    shiftMeta(fields, fromIndex < toIndex ? 'up' : 'down')\n\n    // Reapply the stored field meta at the destination index\n    Object.keys(formApi.fieldInfo)\n      .filter((fieldKey) => fieldKey.startsWith(getFieldPath(field, toIndex)))\n      .forEach((fieldKey) => {\n        const fromKey = fieldKey.replace(\n          getFieldPath(field, toIndex),\n          getFieldPath(field, fromIndex),\n        ) as DeepKeys<TFormData>\n\n        const fromMeta = fromFields.get(fromKey)\n        if (fromMeta) {\n          formApi.setFieldMeta(fieldKey as DeepKeys<TFormData>, fromMeta)\n        }\n      })\n  }\n\n  const handleSwapMode = (\n    fields: DeepKeys<TFormData>[],\n    field: DeepKeys<TFormData>,\n    index: number,\n    secondIndex: number,\n  ) => {\n    fields.forEach((fieldKey) => {\n      if (!fieldKey.toString().startsWith(getFieldPath(field, index))) return\n\n      const swappedKey = fieldKey\n        .toString()\n        .replace(\n          getFieldPath(field, index),\n          getFieldPath(field, secondIndex),\n        ) as DeepKeys<TFormData>\n\n      const [meta1, meta2] = [\n        formApi.getFieldMeta(fieldKey),\n        formApi.getFieldMeta(swappedKey),\n      ]\n\n      if (meta1) formApi.setFieldMeta(swappedKey, meta1)\n      if (meta2) formApi.setFieldMeta(fieldKey, meta2)\n    })\n  }\n\n  return { handleArrayFieldMetaShift }\n}\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 693, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.bun/@tanstack+form-core@1.24.4/node_modules/@tanstack/form-core/dist/esm/EventClient.js","sources":["file:///C:/Proiect/groupware2/groupware/node_modules/.bun/%40tanstack%2Bform-core%401.24.4/node_modules/%40tanstack/form-core/src/EventClient.ts"],"sourcesContent":["import { EventClient } from '@tanstack/devtools-event-client'\n\nimport type { AnyFormOptions, AnyFormState } from './FormApi'\n\ntype ExtractEventNames<T> = T extends `${string}:${infer EventName}`\n  ? EventName\n  : never\n\nexport type BroadcastFormState = {\n  id: string\n  state: AnyFormState\n}\n\nexport type BroadcastFormApi = {\n  id: string\n  state: AnyFormState\n  options: AnyFormOptions\n}\n\nexport type BroadcastFormSubmissionState =\n  | {\n      id: string\n      submissionAttempt: number\n      successful: false\n      stage: 'validateAllFields' | 'validate'\n      errors: any[]\n    }\n  | {\n      id: string\n      submissionAttempt: number\n      successful: false\n      stage: 'inflight'\n      onError: unknown\n    }\n  | {\n      id: string\n      submissionAttempt: number\n      successful: true\n    }\n\nexport type BroadcastFormId = {\n  id: string\n}\n\ntype EventMap = {\n  'form-devtools:form-state': BroadcastFormState\n  'form-devtools:form-api': BroadcastFormApi\n  'form-devtools:form-submission': BroadcastFormSubmissionState\n\n  'form-devtools:request-form-state': BroadcastFormId\n  'form-devtools:request-form-reset': BroadcastFormId\n  'form-devtools:request-form-force-submit': BroadcastFormId\n\n  'form-devtools:form-unmounted': BroadcastFormId\n}\n\nexport type EventClientEventMap = keyof EventMap\n\nexport type EventClientEventNames = ExtractEventNames<EventClientEventMap>\n\nclass FormEventClient extends EventClient<EventMap> {\n  constructor() {\n    super({\n      pluginId: 'form-devtools',\n    })\n  }\n}\n\nexport const formEventClient = new FormEventClient()\n"],"names":[],"mappings":";;;;;;AA4DA,MAAM,wBAAwB,yRAAA,CAAsB;IAClD,aAAc;QACZ,KAAA,CAAM;YACJ,UAAU;QAAA,CACX;IACH;AACF;AAEO,MAAM,kBAAkB,IAAI,gBAAA","debugId":null}},
    {"offset": {"line": 713, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.bun/@tanstack+form-core@1.24.4/node_modules/@tanstack/form-core/dist/esm/FormApi.js","sources":["file:///C:/Proiect/groupware2/groupware/node_modules/.bun/%40tanstack%2Bform-core%401.24.4/node_modules/%40tanstack/form-core/src/FormApi.ts"],"sourcesContent":["import { Derived, Store, batch } from '@tanstack/store'\nimport { throttle } from '@tanstack/pacer'\nimport {\n  deleteBy,\n  determineFormLevelErrorSourceAndValue,\n  evaluate,\n  functionalUpdate,\n  getAsyncValidatorArray,\n  getBy,\n  getSyncValidatorArray,\n  isGlobalFormValidationError,\n  isNonEmptyArray,\n  mergeOpts,\n  setBy,\n  uuid,\n} from './utils'\nimport { defaultValidationLogic } from './ValidationLogic'\n\nimport {\n  isStandardSchemaValidator,\n  standardSchemaValidators,\n} from './standardSchemaValidator'\nimport { defaultFieldMeta, metaHelper } from './metaHelper'\nimport { formEventClient } from './EventClient'\nimport type { ValidationLogicFn } from './ValidationLogic'\nimport type {\n  StandardSchemaV1,\n  StandardSchemaV1Issue,\n  TStandardSchemaValidatorValue,\n} from './standardSchemaValidator'\nimport type {\n  AnyFieldApi,\n  AnyFieldMeta,\n  AnyFieldMetaBase,\n  FieldApi,\n} from './FieldApi'\nimport type {\n  ExtractGlobalFormError,\n  FieldManipulator,\n  FormValidationError,\n  FormValidationErrorMap,\n  ListenerCause,\n  UpdateMetaOptions,\n  ValidationCause,\n  ValidationError,\n  ValidationErrorMap,\n  ValidationErrorMapKeys,\n} from './types'\nimport type { DeepKeys, DeepKeysOfType, DeepValue } from './util-types'\nimport type { Updater } from './utils'\n\n/**\n * @private\n */\n// TODO: Add the `Unwrap` type to the errors\ntype FormErrorMapFromValidator<\n  TFormData,\n  TOnMount extends undefined | FormValidateOrFn<TFormData>,\n  TOnChange extends undefined | FormValidateOrFn<TFormData>,\n  TOnChangeAsync extends undefined | FormAsyncValidateOrFn<TFormData>,\n  TOnBlur extends undefined | FormValidateOrFn<TFormData>,\n  TOnBlurAsync extends undefined | FormAsyncValidateOrFn<TFormData>,\n  TOnSubmit extends undefined | FormValidateOrFn<TFormData>,\n  TOnSubmitAsync extends undefined | FormAsyncValidateOrFn<TFormData>,\n  TOnDynamic extends undefined | FormValidateOrFn<TFormData>,\n  TOnDynamicAsync extends undefined | FormAsyncValidateOrFn<TFormData>,\n> = Partial<\n  Record<\n    DeepKeys<TFormData>,\n    ValidationErrorMap<\n      TOnMount,\n      TOnChange,\n      TOnChangeAsync,\n      TOnBlur,\n      TOnBlurAsync,\n      TOnSubmit,\n      TOnSubmitAsync,\n      TOnDynamic,\n      TOnDynamicAsync\n    >\n  >\n>\n\nexport type FormValidateFn<TFormData> = (props: {\n  value: TFormData\n  formApi: FormApi<\n    TFormData,\n    // This is technically an edge-type; which we try to keep non-`any`, but in this case\n    // It's referring to an inaccessible type from the field validate function inner types, so it's not a big deal\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any\n  >\n}) => unknown\n\n/**\n * @private\n */\nexport type FormValidateOrFn<TFormData> =\n  | FormValidateFn<TFormData>\n  | StandardSchemaV1<TFormData, unknown>\n\nexport type UnwrapFormValidateOrFn<\n  TValidateOrFn extends undefined | FormValidateOrFn<any>,\n> = [TValidateOrFn] extends [FormValidateFn<any>]\n  ? ExtractGlobalFormError<ReturnType<TValidateOrFn>>\n  : [TValidateOrFn] extends [StandardSchemaV1<any, any>]\n    ? Record<string, StandardSchemaV1Issue[]>\n    : undefined\n\n/**\n * @private\n */\nexport type FormValidateAsyncFn<TFormData> = (props: {\n  value: TFormData\n  formApi: FormApi<\n    TFormData,\n    // This is technically an edge-type; which we try to keep non-`any`, but in this case\n    // It's referring to an inaccessible type from the field validate function inner types, so it's not a big deal\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any\n  >\n  signal: AbortSignal\n}) => unknown | Promise<unknown>\n\nexport type FormValidator<TFormData, TType, TFn = unknown> = {\n  validate(options: { value: TType }, fn: TFn): ValidationError\n  validateAsync(\n    options: { value: TType },\n    fn: TFn,\n  ): Promise<FormValidationError<TFormData>>\n}\n\ntype ValidationPromiseResult<TFormData> =\n  | {\n      fieldErrors: Partial<Record<DeepKeys<TFormData>, ValidationError>>\n      errorMapKey: ValidationErrorMapKeys\n    }\n  | undefined\n\n/**\n * @private\n */\nexport type FormAsyncValidateOrFn<TFormData> =\n  | FormValidateAsyncFn<TFormData>\n  | StandardSchemaV1<TFormData, unknown>\n\nexport type UnwrapFormAsyncValidateOrFn<\n  TValidateOrFn extends undefined | FormAsyncValidateOrFn<any>,\n> = [TValidateOrFn] extends [FormValidateAsyncFn<any>]\n  ? ExtractGlobalFormError<Awaited<ReturnType<TValidateOrFn>>>\n  : [TValidateOrFn] extends [StandardSchemaV1<any, any>]\n    ? Record<string, StandardSchemaV1Issue[]>\n    : undefined\n\nexport interface FormValidators<\n  TFormData,\n  TOnMount extends undefined | FormValidateOrFn<TFormData>,\n  TOnChange extends undefined | FormValidateOrFn<TFormData>,\n  TOnChangeAsync extends undefined | FormAsyncValidateOrFn<TFormData>,\n  TOnBlur extends undefined | FormValidateOrFn<TFormData>,\n  TOnBlurAsync extends undefined | FormAsyncValidateOrFn<TFormData>,\n  TOnSubmit extends undefined | FormValidateOrFn<TFormData>,\n  TOnSubmitAsync extends undefined | FormAsyncValidateOrFn<TFormData>,\n  TOnDynamic extends undefined | FormValidateOrFn<TFormData>,\n  TOnDynamicAsync extends undefined | FormAsyncValidateOrFn<TFormData>,\n> {\n  /**\n   * Optional function that fires as soon as the component mounts.\n   */\n  onMount?: TOnMount\n  /**\n   * Optional function that checks the validity of your data whenever a value changes\n   */\n  onChange?: TOnChange\n  /**\n   * Optional onChange asynchronous counterpart to onChange. Useful for more complex validation logic that might involve server requests.\n   */\n  onChangeAsync?: TOnChangeAsync\n  /**\n   * The default time in milliseconds that if set to a number larger than 0, will debounce the async validation event by this length of time in milliseconds.\n   */\n  onChangeAsyncDebounceMs?: number\n  /**\n   * Optional function that validates the form data when a field loses focus, returns a `FormValidationError`\n   */\n  onBlur?: TOnBlur\n  /**\n   * Optional onBlur asynchronous validation method for when a field loses focus returns a ` FormValidationError` or a promise of `Promise<FormValidationError>`\n   */\n  onBlurAsync?: TOnBlurAsync\n  /**\n   * The default time in milliseconds that if set to a number larger than 0, will debounce the async validation event by this length of time in milliseconds.\n   */\n  onBlurAsyncDebounceMs?: number\n  onSubmit?: TOnSubmit\n  onSubmitAsync?: TOnSubmitAsync\n  onDynamic?: TOnDynamic\n  onDynamicAsync?: TOnDynamicAsync\n  onDynamicAsyncDebounceMs?: number\n}\n\n/**\n * @private\n */\nexport interface FormTransform<\n  TFormData,\n  TOnMount extends undefined | FormValidateOrFn<TFormData>,\n  TOnChange extends undefined | FormValidateOrFn<TFormData>,\n  TOnChangeAsync extends undefined | FormAsyncValidateOrFn<TFormData>,\n  TOnBlur extends undefined | FormValidateOrFn<TFormData>,\n  TOnBlurAsync extends undefined | FormAsyncValidateOrFn<TFormData>,\n  TOnSubmit extends undefined | FormValidateOrFn<TFormData>,\n  TOnSubmitAsync extends undefined | FormAsyncValidateOrFn<TFormData>,\n  TOnDynamic extends undefined | FormValidateOrFn<TFormData>,\n  TOnDynamicAsync extends undefined | FormAsyncValidateOrFn<TFormData>,\n  TOnServer extends undefined | FormAsyncValidateOrFn<TFormData>,\n  TSubmitMeta = never,\n> {\n  fn: (\n    formBase: FormApi<\n      TFormData,\n      TOnMount,\n      TOnChange,\n      TOnChangeAsync,\n      TOnBlur,\n      TOnBlurAsync,\n      TOnSubmit,\n      TOnSubmitAsync,\n      TOnDynamic,\n      TOnDynamicAsync,\n      TOnServer,\n      TSubmitMeta\n    >,\n  ) => FormApi<\n    TFormData,\n    TOnMount,\n    TOnChange,\n    TOnChangeAsync,\n    TOnBlur,\n    TOnBlurAsync,\n    TOnSubmit,\n    TOnSubmitAsync,\n    TOnDynamic,\n    TOnDynamicAsync,\n    TOnServer,\n    TSubmitMeta\n  >\n  deps: unknown[]\n}\n\nexport interface FormListeners<\n  TFormData,\n  TOnMount extends undefined | FormValidateOrFn<TFormData>,\n  TOnChange extends undefined | FormValidateOrFn<TFormData>,\n  TOnChangeAsync extends undefined | FormAsyncValidateOrFn<TFormData>,\n  TOnBlur extends undefined | FormValidateOrFn<TFormData>,\n  TOnBlurAsync extends undefined | FormAsyncValidateOrFn<TFormData>,\n  TOnSubmit extends undefined | FormValidateOrFn<TFormData>,\n  TOnSubmitAsync extends undefined | FormAsyncValidateOrFn<TFormData>,\n  TOnDynamic extends undefined | FormValidateOrFn<TFormData>,\n  TOnDynamicAsync extends undefined | FormAsyncValidateOrFn<TFormData>,\n  TOnServer extends undefined | FormAsyncValidateOrFn<TFormData>,\n  TSubmitMeta = never,\n> {\n  onChange?: (props: {\n    formApi: FormApi<\n      TFormData,\n      TOnMount,\n      TOnChange,\n      TOnChangeAsync,\n      TOnBlur,\n      TOnBlurAsync,\n      TOnSubmit,\n      TOnSubmitAsync,\n      TOnDynamic,\n      TOnDynamicAsync,\n      TOnServer,\n      TSubmitMeta\n    >\n    fieldApi: AnyFieldApi\n  }) => void\n  onChangeDebounceMs?: number\n\n  onBlur?: (props: {\n    formApi: FormApi<\n      TFormData,\n      TOnMount,\n      TOnChange,\n      TOnChangeAsync,\n      TOnBlur,\n      TOnBlurAsync,\n      TOnSubmit,\n      TOnSubmitAsync,\n      TOnDynamic,\n      TOnDynamicAsync,\n      TOnServer,\n      TSubmitMeta\n    >\n    fieldApi: AnyFieldApi\n  }) => void\n  onBlurDebounceMs?: number\n\n  onMount?: (props: {\n    formApi: FormApi<\n      TFormData,\n      TOnMount,\n      TOnChange,\n      TOnChangeAsync,\n      TOnBlur,\n      TOnBlurAsync,\n      TOnSubmit,\n      TOnSubmitAsync,\n      TOnDynamic,\n      TOnDynamicAsync,\n      TOnServer,\n      TSubmitMeta\n    >\n  }) => void\n\n  onSubmit?: (props: {\n    formApi: FormApi<\n      TFormData,\n      TOnMount,\n      TOnChange,\n      TOnChangeAsync,\n      TOnBlur,\n      TOnBlurAsync,\n      TOnSubmit,\n      TOnSubmitAsync,\n      TOnDynamic,\n      TOnDynamicAsync,\n      TOnServer,\n      TSubmitMeta\n    >\n    meta: TSubmitMeta\n  }) => void\n}\n\n/**\n * An object representing the base properties of a form, unrelated to any validators\n */\nexport interface BaseFormOptions<in out TFormData, in out TSubmitMeta = never> {\n  /**\n   * Set initial values for your form.\n   */\n  defaultValues?: TFormData\n  /**\n   * onSubmitMeta, the data passed from the handleSubmit handler, to the onSubmit function props\n   */\n  onSubmitMeta?: TSubmitMeta\n}\n\n/**\n * An object representing the options for a form.\n */\nexport interface FormOptions<\n  in out TFormData,\n  in out TOnMount extends undefined | FormValidateOrFn<TFormData>,\n  in out TOnChange extends undefined | FormValidateOrFn<TFormData>,\n  in out TOnChangeAsync extends undefined | FormAsyncValidateOrFn<TFormData>,\n  in out TOnBlur extends undefined | FormValidateOrFn<TFormData>,\n  in out TOnBlurAsync extends undefined | FormAsyncValidateOrFn<TFormData>,\n  in out TOnSubmit extends undefined | FormValidateOrFn<TFormData>,\n  in out TOnSubmitAsync extends undefined | FormAsyncValidateOrFn<TFormData>,\n  in out TOnDynamic extends undefined | FormValidateOrFn<TFormData>,\n  in out TOnDynamicAsync extends undefined | FormAsyncValidateOrFn<TFormData>,\n  in out TOnServer extends undefined | FormAsyncValidateOrFn<TFormData>,\n  in out TSubmitMeta = never,\n> extends BaseFormOptions<TFormData, TSubmitMeta> {\n  /**\n   * The form name, used for devtools and identification\n   */\n  formId?: string\n  /**\n   * The default state for the form.\n   */\n  defaultState?: Partial<\n    FormState<\n      TFormData,\n      TOnMount,\n      TOnChange,\n      TOnChangeAsync,\n      TOnBlur,\n      TOnBlurAsync,\n      TOnSubmit,\n      TOnSubmitAsync,\n      TOnDynamic,\n      TOnDynamicAsync,\n      TOnServer\n    >\n  >\n  /**\n   * If true, always run async validation, even when sync validation has produced an error. Defaults to undefined.\n   */\n  asyncAlways?: boolean\n  /**\n   * Optional time in milliseconds if you want to introduce a delay before firing off an async action.\n   */\n  asyncDebounceMs?: number\n  /**\n   * If true, allows the form to be submitted in an invalid state i.e. canSubmit will remain true regardless of validation errors. Defaults to undefined.\n   */\n  canSubmitWhenInvalid?: boolean\n  /**\n   * A list of validators to pass to the form\n   */\n  validators?: FormValidators<\n    TFormData,\n    TOnMount,\n    TOnChange,\n    TOnChangeAsync,\n    TOnBlur,\n    TOnBlurAsync,\n    TOnSubmit,\n    TOnSubmitAsync,\n    TOnDynamic,\n    TOnDynamicAsync\n  >\n\n  validationLogic?: ValidationLogicFn\n\n  /**\n   * form level listeners\n   */\n  listeners?: FormListeners<\n    TFormData,\n    TOnMount,\n    TOnChange,\n    TOnChangeAsync,\n    TOnBlur,\n    TOnBlurAsync,\n    TOnSubmit,\n    TOnSubmitAsync,\n    TOnDynamic,\n    TOnDynamicAsync,\n    TOnServer,\n    TSubmitMeta\n  >\n\n  /**\n   * A function to be called when the form is submitted, what should happen once the user submits a valid form returns `any` or a promise `Promise<any>`\n   */\n  onSubmit?: (props: {\n    value: TFormData\n    formApi: FormApi<\n      TFormData,\n      TOnMount,\n      TOnChange,\n      TOnChangeAsync,\n      TOnBlur,\n      TOnBlurAsync,\n      TOnSubmit,\n      TOnSubmitAsync,\n      TOnDynamic,\n      TOnDynamicAsync,\n      TOnServer,\n      TSubmitMeta\n    >\n    meta: TSubmitMeta\n  }) => any | Promise<any>\n  /**\n   * Specify an action for scenarios where the user tries to submit an invalid form.\n   */\n  onSubmitInvalid?: (props: {\n    value: TFormData\n    formApi: FormApi<\n      TFormData,\n      TOnMount,\n      TOnChange,\n      TOnChangeAsync,\n      TOnBlur,\n      TOnBlurAsync,\n      TOnSubmit,\n      TOnSubmitAsync,\n      TOnDynamic,\n      TOnDynamicAsync,\n      TOnServer,\n      TSubmitMeta\n    >\n    meta: TSubmitMeta\n  }) => void\n  transform?: FormTransform<\n    NoInfer<TFormData>,\n    NoInfer<TOnMount>,\n    NoInfer<TOnChange>,\n    NoInfer<TOnChangeAsync>,\n    NoInfer<TOnBlur>,\n    NoInfer<TOnBlurAsync>,\n    NoInfer<TOnSubmit>,\n    NoInfer<TOnSubmitAsync>,\n    NoInfer<TOnDynamic>,\n    NoInfer<TOnDynamicAsync>,\n    NoInfer<TOnServer>,\n    NoInfer<TSubmitMeta>\n  >\n}\n\nexport type AnyFormOptions = FormOptions<\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any\n>\n\n/**\n * An object representing the validation metadata for a field. Not intended for public usage.\n */\nexport type ValidationMeta = {\n  /**\n   * An abort controller stored in memory to cancel previous async validation attempts.\n   */\n  lastAbortController: AbortController\n}\n\n/**\n * An object representing the field information for a specific field within the form.\n */\nexport type FieldInfo<TFormData> = {\n  /**\n   * An instance of the FieldAPI.\n   */\n  instance: FieldApi<\n    TFormData,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any\n  > | null\n  /**\n   * A record of field validation internal handling.\n   */\n  validationMetaMap: Record<ValidationErrorMapKeys, ValidationMeta | undefined>\n}\n\n/**\n * An object representing the current state of the form.\n */\nexport type BaseFormState<\n  in out TFormData,\n  in out TOnMount extends undefined | FormValidateOrFn<TFormData>,\n  in out TOnChange extends undefined | FormValidateOrFn<TFormData>,\n  in out TOnChangeAsync extends undefined | FormAsyncValidateOrFn<TFormData>,\n  in out TOnBlur extends undefined | FormValidateOrFn<TFormData>,\n  in out TOnBlurAsync extends undefined | FormAsyncValidateOrFn<TFormData>,\n  in out TOnSubmit extends undefined | FormValidateOrFn<TFormData>,\n  in out TOnSubmitAsync extends undefined | FormAsyncValidateOrFn<TFormData>,\n  in out TOnDynamic extends undefined | FormValidateOrFn<TFormData>,\n  in out TOnDynamicAsync extends undefined | FormAsyncValidateOrFn<TFormData>,\n  in out TOnServer extends undefined | FormAsyncValidateOrFn<TFormData>,\n> = {\n  /**\n   * The current values of the form fields.\n   */\n  values: TFormData\n  /**\n   * The error map for the form itself.\n   */\n  errorMap: ValidationErrorMap<\n    UnwrapFormValidateOrFn<TOnMount>,\n    UnwrapFormValidateOrFn<TOnChange>,\n    UnwrapFormAsyncValidateOrFn<TOnChangeAsync>,\n    UnwrapFormValidateOrFn<TOnBlur>,\n    UnwrapFormAsyncValidateOrFn<TOnBlurAsync>,\n    UnwrapFormValidateOrFn<TOnSubmit>,\n    UnwrapFormAsyncValidateOrFn<TOnSubmitAsync>,\n    UnwrapFormValidateOrFn<TOnDynamic>,\n    UnwrapFormAsyncValidateOrFn<TOnDynamicAsync>,\n    UnwrapFormAsyncValidateOrFn<TOnServer>\n  >\n  /**\n   * An internal mechanism used for keeping track of validation logic in a form.\n   */\n  validationMetaMap: Record<ValidationErrorMapKeys, ValidationMeta | undefined>\n  /**\n   * A record of field metadata for each field in the form, not including the derived properties, like `errors` and such\n   */\n  fieldMetaBase: Record<DeepKeys<TFormData>, AnyFieldMetaBase>\n  /**\n   * A boolean indicating if the form is currently in the process of being submitted after `handleSubmit` is called.\n   *\n   * Goes back to `false` when submission completes for one of the following reasons:\n   * - the validation step returned errors.\n   * - the `onSubmit` function has completed.\n   *\n   * Note: if you're running async operations in your `onSubmit` function make sure to await them to ensure `isSubmitting` is set to `false` only when the async operation completes.\n   *\n   * This is useful for displaying loading indicators or disabling form inputs during submission.\n   *\n   */\n  isSubmitting: boolean\n  /**\n   * A boolean indicating if the `onSubmit` function has completed successfully.\n   *\n   * Goes back to `false` at each new submission attempt.\n   *\n   * Note: you can use isSubmitting to check if the form is currently submitting.\n   */\n  isSubmitted: boolean\n  /**\n   * A boolean indicating if the form or any of its fields are currently validating.\n   */\n  isValidating: boolean\n  /**\n   * A counter for tracking the number of submission attempts.\n   */\n  submissionAttempts: number\n  /**\n   * A boolean indicating if the last submission was successful.\n   */\n  isSubmitSuccessful: boolean\n  /**\n   * @private, used to force a re-evaluation of the form state when options change\n   */\n  _force_re_eval?: boolean\n}\n\nexport type DerivedFormState<\n  in out TFormData,\n  in out TOnMount extends undefined | FormValidateOrFn<TFormData>,\n  in out TOnChange extends undefined | FormValidateOrFn<TFormData>,\n  in out TOnChangeAsync extends undefined | FormAsyncValidateOrFn<TFormData>,\n  in out TOnBlur extends undefined | FormValidateOrFn<TFormData>,\n  in out TOnBlurAsync extends undefined | FormAsyncValidateOrFn<TFormData>,\n  in out TOnSubmit extends undefined | FormValidateOrFn<TFormData>,\n  in out TOnSubmitAsync extends undefined | FormAsyncValidateOrFn<TFormData>,\n  in out TOnDynamic extends undefined | FormValidateOrFn<TFormData>,\n  in out TOnDynamicAsync extends undefined | FormAsyncValidateOrFn<TFormData>,\n  in out TOnServer extends undefined | FormAsyncValidateOrFn<TFormData>,\n> = {\n  /**\n   * A boolean indicating if the form is currently validating.\n   */\n  isFormValidating: boolean\n  /**\n   * A boolean indicating if the form is valid.\n   */\n  isFormValid: boolean\n  /**\n   * The error array for the form itself.\n   */\n  errors: Array<\n    | UnwrapFormValidateOrFn<TOnMount>\n    | UnwrapFormValidateOrFn<TOnChange>\n    | UnwrapFormAsyncValidateOrFn<TOnChangeAsync>\n    | UnwrapFormValidateOrFn<TOnBlur>\n    | UnwrapFormAsyncValidateOrFn<TOnBlurAsync>\n    | UnwrapFormValidateOrFn<TOnSubmit>\n    | UnwrapFormAsyncValidateOrFn<TOnSubmitAsync>\n    | UnwrapFormValidateOrFn<TOnDynamic>\n    | UnwrapFormAsyncValidateOrFn<TOnDynamicAsync>\n    | UnwrapFormAsyncValidateOrFn<TOnServer>\n  >\n  /**\n   * A boolean indicating if any of the form fields are currently validating.\n   */\n  isFieldsValidating: boolean\n  /**\n   * A boolean indicating if all the form fields are valid. Evaluates `true` if there are no field errors.\n   */\n  isFieldsValid: boolean\n  /**\n   * A boolean indicating if any of the form fields have been touched.\n   */\n  isTouched: boolean\n  /**\n   * A boolean indicating if any of the form fields have been blurred.\n   */\n  isBlurred: boolean\n  /**\n   * A boolean indicating if any of the form's fields' values have been modified by the user. Evaluates `true` if the user have modified at least one of the fields. Opposite of `isPristine`.\n   */\n  isDirty: boolean\n  /**\n   * A boolean indicating if none of the form's fields' values have been modified by the user. Evaluates `true` if the user have not modified any of the fields. Opposite of `isDirty`.\n   */\n  isPristine: boolean\n  /**\n   * A boolean indicating if all of the form's fields are the same as default values.\n   */\n  isDefaultValue: boolean\n  /**\n   * A boolean indicating if the form and all its fields are valid. Evaluates `true` if there are no errors.\n   */\n  isValid: boolean\n  /**\n   * A boolean indicating if the form can be submitted based on its current state.\n   */\n  canSubmit: boolean\n  /**\n   * A record of field metadata for each field in the form.\n   */\n  fieldMeta: Record<DeepKeys<TFormData>, AnyFieldMeta>\n}\n\nexport interface FormState<\n  in out TFormData,\n  in out TOnMount extends undefined | FormValidateOrFn<TFormData>,\n  in out TOnChange extends undefined | FormValidateOrFn<TFormData>,\n  in out TOnChangeAsync extends undefined | FormAsyncValidateOrFn<TFormData>,\n  in out TOnBlur extends undefined | FormValidateOrFn<TFormData>,\n  in out TOnBlurAsync extends undefined | FormAsyncValidateOrFn<TFormData>,\n  in out TOnSubmit extends undefined | FormValidateOrFn<TFormData>,\n  in out TOnSubmitAsync extends undefined | FormAsyncValidateOrFn<TFormData>,\n  in out TOnDynamic extends undefined | FormValidateOrFn<TFormData>,\n  in out TOnDynamicAsync extends undefined | FormAsyncValidateOrFn<TFormData>,\n  in out TOnServer extends undefined | FormAsyncValidateOrFn<TFormData>,\n> extends BaseFormState<\n      TFormData,\n      TOnMount,\n      TOnChange,\n      TOnChangeAsync,\n      TOnBlur,\n      TOnBlurAsync,\n      TOnSubmit,\n      TOnSubmitAsync,\n      TOnDynamic,\n      TOnDynamicAsync,\n      TOnServer\n    >,\n    DerivedFormState<\n      TFormData,\n      TOnMount,\n      TOnChange,\n      TOnChangeAsync,\n      TOnBlur,\n      TOnBlurAsync,\n      TOnSubmit,\n      TOnSubmitAsync,\n      TOnDynamic,\n      TOnDynamicAsync,\n      TOnServer\n    > {}\n\nexport type AnyFormState = FormState<\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any\n>\n\nfunction getDefaultFormState<\n  TFormData,\n  TOnMount extends undefined | FormValidateOrFn<TFormData>,\n  TOnChange extends undefined | FormValidateOrFn<TFormData>,\n  TOnChangeAsync extends undefined | FormAsyncValidateOrFn<TFormData>,\n  TOnBlur extends undefined | FormValidateOrFn<TFormData>,\n  TOnBlurAsync extends undefined | FormAsyncValidateOrFn<TFormData>,\n  TOnSubmit extends undefined | FormValidateOrFn<TFormData>,\n  TOnSubmitAsync extends undefined | FormAsyncValidateOrFn<TFormData>,\n  TOnDynamic extends undefined | FormValidateOrFn<TFormData>,\n  TOnDynamicAsync extends undefined | FormAsyncValidateOrFn<TFormData>,\n  TOnServer extends undefined | FormAsyncValidateOrFn<TFormData>,\n>(\n  defaultState: Partial<\n    FormState<\n      TFormData,\n      TOnMount,\n      TOnChange,\n      TOnChangeAsync,\n      TOnBlur,\n      TOnBlurAsync,\n      TOnSubmit,\n      TOnSubmitAsync,\n      TOnDynamic,\n      TOnDynamicAsync,\n      TOnServer\n    >\n  >,\n): BaseFormState<\n  TFormData,\n  TOnMount,\n  TOnChange,\n  TOnChangeAsync,\n  TOnBlur,\n  TOnBlurAsync,\n  TOnSubmit,\n  TOnSubmitAsync,\n  TOnDynamic,\n  TOnDynamicAsync,\n  TOnServer\n> {\n  return {\n    values: defaultState.values ?? ({} as never),\n    errorMap: defaultState.errorMap ?? {},\n    fieldMetaBase: defaultState.fieldMetaBase ?? ({} as never),\n    isSubmitted: defaultState.isSubmitted ?? false,\n    isSubmitting: defaultState.isSubmitting ?? false,\n    isValidating: defaultState.isValidating ?? false,\n    submissionAttempts: defaultState.submissionAttempts ?? 0,\n    isSubmitSuccessful: defaultState.isSubmitSuccessful ?? false,\n    validationMetaMap: defaultState.validationMetaMap ?? {\n      onChange: undefined,\n      onBlur: undefined,\n      onSubmit: undefined,\n      onMount: undefined,\n      onServer: undefined,\n      onDynamic: undefined,\n    },\n  }\n}\n\n/**\n * @public\n *\n * A type representing the Form API with all generics set to `any` for convenience.\n */\nexport type AnyFormApi = FormApi<\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any\n>\n\n/**\n * A class representing the Form API. It handles the logic and interactions with the form state.\n *\n * Normally, you will not need to create a new `FormApi` instance directly. Instead, you will use a framework\n * hook/function like `useForm` or `createForm` to create a new instance for you that uses your framework's reactivity model.\n * However, if you need to create a new instance manually, you can do so by calling the `new FormApi` constructor.\n */\nexport class FormApi<\n  in out TFormData,\n  in out TOnMount extends undefined | FormValidateOrFn<TFormData>,\n  in out TOnChange extends undefined | FormValidateOrFn<TFormData>,\n  in out TOnChangeAsync extends undefined | FormAsyncValidateOrFn<TFormData>,\n  in out TOnBlur extends undefined | FormValidateOrFn<TFormData>,\n  in out TOnBlurAsync extends undefined | FormAsyncValidateOrFn<TFormData>,\n  in out TOnSubmit extends undefined | FormValidateOrFn<TFormData>,\n  in out TOnSubmitAsync extends undefined | FormAsyncValidateOrFn<TFormData>,\n  in out TOnDynamic extends undefined | FormValidateOrFn<TFormData>,\n  in out TOnDynamicAsync extends undefined | FormAsyncValidateOrFn<TFormData>,\n  in out TOnServer extends undefined | FormAsyncValidateOrFn<TFormData>,\n  in out TSubmitMeta = never,\n> implements FieldManipulator<TFormData, TSubmitMeta>\n{\n  /**\n   * The options for the form.\n   */\n  options: FormOptions<\n    TFormData,\n    TOnMount,\n    TOnChange,\n    TOnChangeAsync,\n    TOnBlur,\n    TOnBlurAsync,\n    TOnSubmit,\n    TOnSubmitAsync,\n    TOnDynamic,\n    TOnDynamicAsync,\n    TOnServer,\n    TSubmitMeta\n  > = {}\n  baseStore!: Store<\n    BaseFormState<\n      TFormData,\n      TOnMount,\n      TOnChange,\n      TOnChangeAsync,\n      TOnBlur,\n      TOnBlurAsync,\n      TOnSubmit,\n      TOnSubmitAsync,\n      TOnDynamic,\n      TOnDynamicAsync,\n      TOnServer\n    >\n  >\n  fieldMetaDerived!: Derived<Record<DeepKeys<TFormData>, AnyFieldMeta>>\n  store!: Derived<\n    FormState<\n      TFormData,\n      TOnMount,\n      TOnChange,\n      TOnChangeAsync,\n      TOnBlur,\n      TOnBlurAsync,\n      TOnSubmit,\n      TOnSubmitAsync,\n      TOnDynamic,\n      TOnDynamicAsync,\n      TOnServer\n    >\n  >\n  /**\n   * A record of field information for each field in the form.\n   */\n  fieldInfo: Record<DeepKeys<TFormData>, FieldInfo<TFormData>> = {} as any\n\n  get state() {\n    return this.store.state\n  }\n\n  /**\n   * @private\n   */\n  prevTransformArray: unknown[] = []\n\n  /**\n   * @private\n   */\n  timeoutIds: {\n    validations: Record<ValidationCause, ReturnType<typeof setTimeout> | null>\n    listeners: Record<ListenerCause, ReturnType<typeof setTimeout> | null>\n    formListeners: Record<ListenerCause, ReturnType<typeof setTimeout> | null>\n  }\n  /**\n   * @private\n   */\n  private _formId: string\n  /**\n   * @private\n   */\n  private _devtoolsSubmissionOverride: boolean\n\n  /**\n   * Constructs a new `FormApi` instance with the given form options.\n   */\n  constructor(\n    opts?: FormOptions<\n      TFormData,\n      TOnMount,\n      TOnChange,\n      TOnChangeAsync,\n      TOnBlur,\n      TOnBlurAsync,\n      TOnSubmit,\n      TOnSubmitAsync,\n      TOnDynamic,\n      TOnDynamicAsync,\n      TOnServer,\n      TSubmitMeta\n    >,\n  ) {\n    this.timeoutIds = {\n      validations: {} as Record<ValidationCause, never>,\n      listeners: {} as Record<ListenerCause, never>,\n      formListeners: {} as Record<ListenerCause, never>,\n    }\n\n    this._formId = opts?.formId ?? uuid()\n\n    this._devtoolsSubmissionOverride = false\n\n    this.baseStore = new Store(\n      getDefaultFormState({\n        ...(opts?.defaultState as any),\n        values: opts?.defaultValues ?? opts?.defaultState?.values,\n        isFormValid: true,\n      }),\n    )\n\n    this.fieldMetaDerived = new Derived({\n      deps: [this.baseStore],\n      fn: ({ prevDepVals, currDepVals, prevVal: _prevVal }) => {\n        const prevVal = _prevVal as\n          | Record<DeepKeys<TFormData>, AnyFieldMeta>\n          | undefined\n        const prevBaseStore = prevDepVals?.[0]\n        const currBaseStore = currDepVals[0]\n\n        let originalMetaCount = 0\n\n        const fieldMeta = {} as FormState<\n          TFormData,\n          TOnMount,\n          TOnChange,\n          TOnChangeAsync,\n          TOnBlur,\n          TOnBlurAsync,\n          TOnSubmit,\n          TOnSubmitAsync,\n          TOnDynamic,\n          TOnDynamicAsync,\n          TOnServer\n        >['fieldMeta']\n\n        for (const fieldName of Object.keys(\n          currBaseStore.fieldMetaBase,\n        ) as Array<keyof typeof currBaseStore.fieldMetaBase>) {\n          const currBaseMeta = currBaseStore.fieldMetaBase[\n            fieldName as never\n          ] as AnyFieldMetaBase\n\n          const prevBaseMeta = prevBaseStore?.fieldMetaBase[\n            fieldName as never\n          ] as AnyFieldMetaBase | undefined\n\n          const prevFieldInfo =\n            prevVal?.[fieldName as never as keyof typeof prevVal]\n\n          const curFieldVal = getBy(currBaseStore.values, fieldName)\n\n          let fieldErrors = prevFieldInfo?.errors\n          if (\n            !prevBaseMeta ||\n            currBaseMeta.errorMap !== prevBaseMeta.errorMap\n          ) {\n            // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n            fieldErrors = Object.values(currBaseMeta.errorMap ?? {}).filter(\n              (val) => val !== undefined,\n            ) as never\n\n            // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n            const fieldInstance = this.getFieldInfo(fieldName)?.instance\n\n            if (fieldInstance && !fieldInstance.options.disableErrorFlat) {\n              fieldErrors = (fieldErrors as undefined | string[])?.flat(\n                1,\n              ) as never\n            }\n          }\n\n          // As primitives, we don't need to aggressively persist the same referential value for performance reasons\n          const isFieldValid = !isNonEmptyArray(fieldErrors ?? [])\n          const isFieldPristine = !currBaseMeta.isDirty\n          const isDefaultValue =\n            evaluate(\n              curFieldVal,\n              getBy(this.options.defaultValues, fieldName),\n            ) ||\n            evaluate(\n              curFieldVal,\n              // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n              this.getFieldInfo(fieldName)?.instance?.options.defaultValue,\n            )\n\n          if (\n            prevFieldInfo &&\n            prevFieldInfo.isPristine === isFieldPristine &&\n            prevFieldInfo.isValid === isFieldValid &&\n            prevFieldInfo.isDefaultValue === isDefaultValue &&\n            prevFieldInfo.errors === fieldErrors &&\n            currBaseMeta === prevBaseMeta\n          ) {\n            fieldMeta[fieldName] = prevFieldInfo\n            originalMetaCount++\n            continue\n          }\n\n          fieldMeta[fieldName] = {\n            ...currBaseMeta,\n            errors: fieldErrors,\n            isPristine: isFieldPristine,\n            isValid: isFieldValid,\n            isDefaultValue: isDefaultValue,\n          } as AnyFieldMeta\n        }\n\n        if (!Object.keys(currBaseStore.fieldMetaBase).length) return fieldMeta\n\n        if (\n          prevVal &&\n          originalMetaCount === Object.keys(currBaseStore.fieldMetaBase).length\n        ) {\n          return prevVal\n        }\n\n        return fieldMeta\n      },\n    })\n\n    this.store = new Derived({\n      deps: [this.baseStore, this.fieldMetaDerived],\n      fn: ({ prevDepVals, currDepVals, prevVal: _prevVal }) => {\n        const prevVal = _prevVal as\n          | FormState<\n              TFormData,\n              TOnMount,\n              TOnChange,\n              TOnChangeAsync,\n              TOnBlur,\n              TOnBlurAsync,\n              TOnSubmit,\n              TOnSubmitAsync,\n              TOnDynamic,\n              TOnDynamicAsync,\n              TOnServer\n            >\n          | undefined\n        const prevBaseStore = prevDepVals?.[0]\n        const currBaseStore = currDepVals[0]\n        const currFieldMeta = currDepVals[1]\n\n        // Computed state\n        const fieldMetaValues = Object.values(currFieldMeta).filter(\n          Boolean,\n        ) as AnyFieldMeta[]\n\n        const isFieldsValidating = fieldMetaValues.some(\n          (field) => field.isValidating,\n        )\n\n        const isFieldsValid = fieldMetaValues.every((field) => field.isValid)\n\n        const isTouched = fieldMetaValues.some((field) => field.isTouched)\n        const isBlurred = fieldMetaValues.some((field) => field.isBlurred)\n        const isDefaultValue = fieldMetaValues.every(\n          (field) => field.isDefaultValue,\n        )\n\n        const shouldInvalidateOnMount =\n          // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n          isTouched && currBaseStore.errorMap?.onMount\n\n        const isDirty = fieldMetaValues.some((field) => field.isDirty)\n        const isPristine = !isDirty\n\n        const hasOnMountError = Boolean(\n          // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n          currBaseStore.errorMap?.onMount ||\n            // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n            fieldMetaValues.some((f) => f?.errorMap?.onMount),\n        )\n\n        const isValidating = !!isFieldsValidating\n\n        // As `errors` is not a primitive, we need to aggressively persist the same referencial value for performance reasons\n        let errors = prevVal?.errors ?? []\n        if (\n          !prevBaseStore ||\n          currBaseStore.errorMap !== prevBaseStore.errorMap\n        ) {\n          errors = Object.values(currBaseStore.errorMap).reduce<\n            Array<\n              | UnwrapFormValidateOrFn<TOnMount>\n              | UnwrapFormValidateOrFn<TOnChange>\n              | UnwrapFormAsyncValidateOrFn<TOnChangeAsync>\n              | UnwrapFormValidateOrFn<TOnBlur>\n              | UnwrapFormAsyncValidateOrFn<TOnBlurAsync>\n              | UnwrapFormValidateOrFn<TOnSubmit>\n              | UnwrapFormAsyncValidateOrFn<TOnSubmitAsync>\n              | UnwrapFormAsyncValidateOrFn<TOnServer>\n            >\n          >((prev, curr) => {\n            if (curr === undefined) return prev\n\n            if (curr && isGlobalFormValidationError(curr)) {\n              prev.push(curr.form as never)\n              return prev\n            }\n            prev.push(curr as never)\n            return prev\n          }, [])\n        }\n\n        const isFormValid = errors.length === 0\n        const isValid = isFieldsValid && isFormValid\n        const submitInvalid = this.options.canSubmitWhenInvalid ?? false\n        const canSubmit =\n          (currBaseStore.submissionAttempts === 0 &&\n            !isTouched &&\n            !hasOnMountError) ||\n          (!isValidating && !currBaseStore.isSubmitting && isValid) ||\n          submitInvalid\n\n        let errorMap = currBaseStore.errorMap\n        if (shouldInvalidateOnMount) {\n          errors = errors.filter(\n            (err) => err !== currBaseStore.errorMap.onMount,\n          )\n          errorMap = Object.assign(errorMap, { onMount: undefined })\n        }\n\n        if (\n          prevVal &&\n          prevBaseStore &&\n          prevVal.errorMap === errorMap &&\n          prevVal.fieldMeta === this.fieldMetaDerived.state &&\n          prevVal.errors === errors &&\n          prevVal.isFieldsValidating === isFieldsValidating &&\n          prevVal.isFieldsValid === isFieldsValid &&\n          prevVal.isFormValid === isFormValid &&\n          prevVal.isValid === isValid &&\n          prevVal.canSubmit === canSubmit &&\n          prevVal.isTouched === isTouched &&\n          prevVal.isBlurred === isBlurred &&\n          prevVal.isPristine === isPristine &&\n          prevVal.isDefaultValue === isDefaultValue &&\n          prevVal.isDirty === isDirty &&\n          evaluate(prevBaseStore, currBaseStore)\n        ) {\n          return prevVal\n        }\n\n        let state = {\n          ...currBaseStore,\n          errorMap,\n          fieldMeta: this.fieldMetaDerived.state,\n          errors,\n          isFieldsValidating,\n          isFieldsValid,\n          isFormValid,\n          isValid,\n          canSubmit,\n          isTouched,\n          isBlurred,\n          isPristine,\n          isDefaultValue,\n          isDirty,\n        } as FormState<\n          TFormData,\n          TOnMount,\n          TOnChange,\n          TOnChangeAsync,\n          TOnBlur,\n          TOnBlurAsync,\n          TOnSubmit,\n          TOnSubmitAsync,\n          TOnDynamic,\n          TOnDynamicAsync,\n          TOnServer\n        >\n\n        // Only run transform if state has shallowly changed - IE how React.useEffect works\n        const transformArray = this.options.transform?.deps ?? []\n        const shouldTransform =\n          transformArray.length !== this.prevTransformArray.length ||\n          transformArray.some((val, i) => val !== this.prevTransformArray[i])\n\n        if (shouldTransform) {\n          const newObj = Object.assign({}, this, { state })\n          // This mutates the state\n          this.options.transform?.fn(newObj)\n          state = newObj.state\n          this.prevTransformArray = transformArray\n        }\n\n        return state\n      },\n    })\n\n    this.handleSubmit = this.handleSubmit.bind(this)\n\n    this.update(opts || {})\n\n    const debouncedDevtoolState = throttle(\n      (state: AnyFormState) =>\n        formEventClient.emit('form-state', {\n          id: this._formId,\n          state: state,\n        }),\n      {\n        wait: 300,\n      },\n    )\n\n    // devtool broadcasts\n    this.store.subscribe(() => {\n      debouncedDevtoolState(this.store.state)\n    })\n\n    // devtool requests\n    formEventClient.on('request-form-state', (e) => {\n      if (e.payload.id === this._formId) {\n        formEventClient.emit('form-api', {\n          id: this._formId,\n          state: this.store.state,\n          options: this.options,\n        })\n      }\n    })\n\n    formEventClient.on('request-form-reset', (e) => {\n      if (e.payload.id === this._formId) {\n        this.reset()\n      }\n    })\n\n    formEventClient.on('request-form-force-submit', (e) => {\n      if (e.payload.id === this._formId) {\n        this._devtoolsSubmissionOverride = true\n        this.handleSubmit()\n        this._devtoolsSubmissionOverride = false\n      }\n    })\n  }\n\n  get formId(): string {\n    return this._formId\n  }\n\n  /**\n   * @private\n   */\n  runValidator<\n    TValue extends TStandardSchemaValidatorValue<TFormData> & {\n      formApi: AnyFormApi\n    },\n    TType extends 'validate' | 'validateAsync',\n  >(props: {\n    validate: TType extends 'validate'\n      ? FormValidateOrFn<TFormData>\n      : FormAsyncValidateOrFn<TFormData>\n    value: TValue\n    type: TType\n  }): unknown {\n    if (isStandardSchemaValidator(props.validate)) {\n      return standardSchemaValidators[props.type](\n        props.value,\n        props.validate,\n      ) as never\n    }\n\n    return (props.validate as FormValidateFn<any>)(props.value) as never\n  }\n\n  mount = () => {\n    const cleanupFieldMetaDerived = this.fieldMetaDerived.mount()\n    const cleanupStoreDerived = this.store.mount()\n    const cleanup = () => {\n      cleanupFieldMetaDerived()\n      cleanupStoreDerived()\n\n      // broadcast form unmount for devtools\n      formEventClient.emit('form-unmounted', {\n        id: this._formId,\n      })\n    }\n\n    this.options.listeners?.onMount?.({ formApi: this })\n\n    const { onMount } = this.options.validators || {}\n\n    // broadcast form state for devtools on mounting\n    formEventClient.emit('form-api', {\n      id: this._formId,\n      state: this.store.state,\n      options: this.options,\n    })\n\n    // if no validation skip\n    if (!onMount) return cleanup\n\n    // validate\n    this.validateSync('mount')\n    return cleanup\n  }\n\n  /**\n   * Updates the form options and form state.\n   */\n  update = (\n    options?: FormOptions<\n      TFormData,\n      TOnMount,\n      TOnChange,\n      TOnChangeAsync,\n      TOnBlur,\n      TOnBlurAsync,\n      TOnSubmit,\n      TOnSubmitAsync,\n      TOnDynamic,\n      TOnDynamicAsync,\n      TOnServer,\n      TSubmitMeta\n    >,\n  ) => {\n    if (!options) return\n\n    const oldOptions = this.options\n\n    // Options need to be updated first so that when the store is updated, the state is correct for the derived state\n    this.options = options\n\n    // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n    const shouldUpdateReeval = !!options.transform?.deps?.some(\n      (val, i) => val !== this.prevTransformArray[i],\n    )\n\n    const shouldUpdateValues =\n      options.defaultValues &&\n      !evaluate(options.defaultValues, oldOptions.defaultValues) &&\n      !this.state.isTouched\n\n    const shouldUpdateState =\n      !evaluate(options.defaultState, oldOptions.defaultState) &&\n      !this.state.isTouched\n\n    if (!shouldUpdateValues && !shouldUpdateState && !shouldUpdateReeval) return\n\n    batch(() => {\n      this.baseStore.setState(() =>\n        getDefaultFormState(\n          Object.assign(\n            {},\n            this.state as any,\n\n            shouldUpdateState ? options.defaultState : {},\n\n            shouldUpdateValues\n              ? {\n                  values: options.defaultValues,\n                }\n              : {},\n\n            shouldUpdateReeval\n              ? { _force_re_eval: !this.state._force_re_eval }\n              : {},\n          ),\n        ),\n      )\n    })\n\n    formEventClient.emit('form-api', {\n      id: this._formId,\n      state: this.store.state,\n      options: this.options,\n    })\n  }\n\n  /**\n   * Resets the form state to the default values.\n   * If values are provided, the form will be reset to those values instead and the default values will be updated.\n   *\n   * @param values - Optional values to reset the form to.\n   * @param opts - Optional options to control the reset behavior.\n   */\n  reset = (values?: TFormData, opts?: { keepDefaultValues?: boolean }) => {\n    const { fieldMeta: currentFieldMeta } = this.state\n    const fieldMetaBase = this.resetFieldMeta(currentFieldMeta)\n\n    if (values && !opts?.keepDefaultValues) {\n      this.options = {\n        ...this.options,\n        defaultValues: values,\n      }\n    }\n\n    this.baseStore.setState(() =>\n      getDefaultFormState({\n        ...(this.options.defaultState as any),\n        values:\n          values ??\n          this.options.defaultValues ??\n          this.options.defaultState?.values,\n        fieldMetaBase,\n      }),\n    )\n  }\n\n  /**\n   * Validates all fields using the correct handlers for a given validation cause.\n   */\n  validateAllFields = async (cause: ValidationCause) => {\n    const fieldValidationPromises: Promise<ValidationError[]>[] = [] as any\n    batch(() => {\n      void (Object.values(this.fieldInfo) as FieldInfo<any>[]).forEach(\n        (field) => {\n          if (!field.instance) return\n          const fieldInstance = field.instance\n          // Validate the field\n          fieldValidationPromises.push(\n            // Remember, `validate` is either a sync operation or a promise\n            Promise.resolve().then(() =>\n              fieldInstance.validate(cause, { skipFormValidation: true }),\n            ),\n          )\n          // If any fields are not touched\n          if (!field.instance.state.meta.isTouched) {\n            // Mark them as touched\n            field.instance.setMeta((prev) => ({ ...prev, isTouched: true }))\n          }\n        },\n      )\n    })\n\n    const fieldErrorMapMap = await Promise.all(fieldValidationPromises)\n    return fieldErrorMapMap.flat()\n  }\n\n  /**\n   * Validates the children of a specified array in the form starting from a given index until the end using the correct handlers for a given validation type.\n   */\n  validateArrayFieldsStartingFrom = async <\n    TField extends DeepKeysOfType<TFormData, any[]>,\n  >(\n    field: TField,\n    index: number,\n    cause: ValidationCause,\n  ) => {\n    const currentValue = this.getFieldValue(field)\n\n    const lastIndex = Array.isArray(currentValue)\n      ? Math.max((currentValue as Array<unknown>).length - 1, 0)\n      : null\n\n    // We have to validate all fields that have shifted (at least the current field)\n    const fieldKeysToValidate = [`${field}[${index}]`]\n    for (let i = index + 1; i <= (lastIndex ?? 0); i++) {\n      fieldKeysToValidate.push(`${field}[${i}]`)\n    }\n\n    // We also have to include all fields that are nested in the shifted fields\n    const fieldsToValidate = Object.keys(this.fieldInfo).filter((fieldKey) =>\n      fieldKeysToValidate.some((key) => fieldKey.startsWith(key)),\n    ) as DeepKeys<TFormData>[]\n\n    // Validate the fields\n    const fieldValidationPromises: Promise<ValidationError[]>[] = [] as any\n    batch(() => {\n      fieldsToValidate.forEach((nestedField) => {\n        fieldValidationPromises.push(\n          Promise.resolve().then(() => this.validateField(nestedField, cause)),\n        )\n      })\n    })\n\n    const fieldErrorMapMap = await Promise.all(fieldValidationPromises)\n    return fieldErrorMapMap.flat()\n  }\n\n  /**\n   * Validates a specified field in the form using the correct handlers for a given validation type.\n   */\n  validateField = <TField extends DeepKeys<TFormData>>(\n    field: TField,\n    cause: ValidationCause,\n  ) => {\n    // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n    const fieldInstance = this.fieldInfo[field]?.instance\n    if (!fieldInstance) return []\n\n    // If the field is not touched (same logic as in validateAllFields)\n    if (!fieldInstance.state.meta.isTouched) {\n      // Mark it as touched\n      fieldInstance.setMeta((prev) => ({ ...prev, isTouched: true }))\n    }\n\n    return fieldInstance.validate(cause)\n  }\n\n  /**\n   * TODO: This code is copied from FieldApi, we should refactor to share\n   * @private\n   */\n  validateSync = (\n    cause: ValidationCause,\n  ): {\n    hasErrored: boolean\n    fieldsErrorMap: FormErrorMapFromValidator<\n      TFormData,\n      TOnMount,\n      TOnChange,\n      TOnChangeAsync,\n      TOnBlur,\n      TOnBlurAsync,\n      TOnSubmit,\n      TOnSubmitAsync,\n      TOnDynamic,\n      TOnDynamicAsync\n    >\n  } => {\n    const validates = getSyncValidatorArray(cause, {\n      ...this.options,\n      form: this,\n      validationLogic: this.options.validationLogic || defaultValidationLogic,\n    })\n\n    let hasErrored = false as boolean\n\n    // This map will only include fields that have errors in the current validation cycle\n    const currentValidationErrorMap: FormErrorMapFromValidator<\n      TFormData,\n      TOnMount,\n      TOnChange,\n      TOnChangeAsync,\n      TOnBlur,\n      TOnBlurAsync,\n      TOnSubmit,\n      TOnSubmitAsync,\n      TOnDynamic,\n      TOnDynamicAsync\n    > = {}\n\n    batch(() => {\n      for (const validateObj of validates) {\n        if (!validateObj.validate) continue\n\n        const rawError = this.runValidator({\n          validate: validateObj.validate,\n          value: {\n            value: this.state.values,\n            formApi: this,\n            validationSource: 'form',\n          },\n          type: 'validate',\n        })\n\n        const { formError, fieldErrors } = normalizeError<TFormData>(rawError)\n\n        const errorMapKey = getErrorMapKey(validateObj.cause)\n\n        for (const field of Object.keys(\n          this.state.fieldMeta,\n        ) as DeepKeys<TFormData>[]) {\n          // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n          if (this.baseStore.state.fieldMetaBase[field] === undefined) {\n            continue\n          }\n\n          const fieldMeta = this.getFieldMeta(field)\n          if (!fieldMeta) continue\n\n          const {\n            errorMap: currentErrorMap,\n            errorSourceMap: currentErrorMapSource,\n          } = fieldMeta\n\n          const newFormValidatorError = fieldErrors?.[field]\n\n          const { newErrorValue, newSource } =\n            determineFormLevelErrorSourceAndValue({\n              newFormValidatorError,\n              isPreviousErrorFromFormValidator:\n                // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n                currentErrorMapSource?.[errorMapKey] === 'form',\n              // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n              previousErrorValue: currentErrorMap?.[errorMapKey],\n            })\n\n          if (newSource === 'form') {\n            currentValidationErrorMap[field] = {\n              ...currentValidationErrorMap[field],\n              [errorMapKey]: newFormValidatorError,\n            }\n          }\n\n          if (\n            // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n            currentErrorMap?.[errorMapKey] !== newErrorValue\n          ) {\n            this.setFieldMeta(field, (prev) => ({\n              ...prev,\n              errorMap: {\n                ...prev.errorMap,\n                [errorMapKey]: newErrorValue,\n              },\n              errorSourceMap: {\n                ...prev.errorSourceMap,\n                [errorMapKey]: newSource,\n              },\n            }))\n          }\n        }\n\n        // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n        if (this.state.errorMap?.[errorMapKey] !== formError) {\n          this.baseStore.setState((prev) => ({\n            ...prev,\n            errorMap: {\n              ...prev.errorMap,\n              [errorMapKey]: formError,\n            },\n          }))\n        }\n\n        if (formError || fieldErrors) {\n          hasErrored = true\n        }\n      }\n\n      /**\n       *  when we have an error for onSubmit in the state, we want\n       *  to clear the error as soon as the user enters a valid value in the field\n       */\n      const submitErrKey = getErrorMapKey('submit')\n      if (\n        // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n        this.state.errorMap?.[submitErrKey] &&\n        cause !== 'submit' &&\n        !hasErrored\n      ) {\n        this.baseStore.setState((prev) => ({\n          ...prev,\n          errorMap: {\n            ...prev.errorMap,\n            [submitErrKey]: undefined,\n          },\n        }))\n      }\n\n      /**\n       *  when we have an error for onServer in the state, we want\n       *  to clear the error as soon as the user enters a valid value in the field\n       */\n      const serverErrKey = getErrorMapKey('server')\n      if (\n        // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n        this.state.errorMap?.[serverErrKey] &&\n        cause !== 'server' &&\n        !hasErrored\n      ) {\n        this.baseStore.setState((prev) => ({\n          ...prev,\n          errorMap: {\n            ...prev.errorMap,\n            [serverErrKey]: undefined,\n          },\n        }))\n      }\n    })\n\n    return { hasErrored, fieldsErrorMap: currentValidationErrorMap }\n  }\n\n  /**\n   * @private\n   */\n  validateAsync = async (\n    cause: ValidationCause,\n  ): Promise<\n    FormErrorMapFromValidator<\n      TFormData,\n      TOnMount,\n      TOnChange,\n      TOnChangeAsync,\n      TOnBlur,\n      TOnBlurAsync,\n      TOnSubmit,\n      TOnSubmitAsync,\n      TOnDynamic,\n      TOnDynamicAsync\n    >\n  > => {\n    const validates = getAsyncValidatorArray(cause, {\n      ...this.options,\n      form: this,\n      validationLogic: this.options.validationLogic || defaultValidationLogic,\n    })\n\n    if (!this.state.isFormValidating) {\n      this.baseStore.setState((prev) => ({ ...prev, isFormValidating: true }))\n    }\n\n    /**\n     * We have to use a for loop and generate our promises this way, otherwise it won't be sync\n     * when there are no validators needed to be run\n     */\n    const promises: Promise<ValidationPromiseResult<TFormData>>[] = []\n\n    let fieldErrorsFromFormValidators:\n      | Partial<Record<DeepKeys<TFormData>, ValidationError>>\n      | undefined\n\n    for (const validateObj of validates) {\n      if (!validateObj.validate) continue\n      const key = getErrorMapKey(validateObj.cause)\n      const fieldValidatorMeta = this.state.validationMetaMap[key]\n\n      fieldValidatorMeta?.lastAbortController.abort()\n      const controller = new AbortController()\n\n      this.state.validationMetaMap[key] = {\n        lastAbortController: controller,\n      }\n\n      promises.push(\n        new Promise<ValidationPromiseResult<TFormData>>(async (resolve) => {\n          let rawError!:\n            | ValidationError\n            | FormValidationError<unknown>\n            | undefined\n          try {\n            rawError = await new Promise((rawResolve, rawReject) => {\n              setTimeout(async () => {\n                if (controller.signal.aborted) return rawResolve(undefined)\n                try {\n                  rawResolve(\n                    await this.runValidator({\n                      validate: validateObj.validate!,\n                      value: {\n                        value: this.state.values,\n                        formApi: this,\n                        validationSource: 'form',\n                        signal: controller.signal,\n                      },\n                      type: 'validateAsync',\n                    }),\n                  )\n                } catch (e) {\n                  rawReject(e)\n                }\n              }, validateObj.debounceMs)\n            })\n          } catch (e: unknown) {\n            rawError = e as ValidationError\n          }\n          const { formError, fieldErrors: fieldErrorsFromNormalizeError } =\n            normalizeError<TFormData>(rawError)\n\n          if (fieldErrorsFromNormalizeError) {\n            fieldErrorsFromFormValidators = fieldErrorsFromFormValidators\n              ? {\n                  ...fieldErrorsFromFormValidators,\n                  ...fieldErrorsFromNormalizeError,\n                }\n              : fieldErrorsFromNormalizeError\n          }\n          const errorMapKey = getErrorMapKey(validateObj.cause)\n\n          for (const field of Object.keys(\n            this.state.fieldMeta,\n          ) as DeepKeys<TFormData>[]) {\n            // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n            if (this.baseStore.state.fieldMetaBase[field] === undefined) {\n              continue\n            }\n\n            const fieldMeta = this.getFieldMeta(field)\n            if (!fieldMeta) continue\n\n            const {\n              errorMap: currentErrorMap,\n              errorSourceMap: currentErrorMapSource,\n            } = fieldMeta\n\n            const newFormValidatorError = fieldErrorsFromFormValidators?.[field]\n\n            const { newErrorValue, newSource } =\n              determineFormLevelErrorSourceAndValue({\n                newFormValidatorError,\n                isPreviousErrorFromFormValidator:\n                  // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n                  currentErrorMapSource?.[errorMapKey] === 'form',\n                // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n                previousErrorValue: currentErrorMap?.[errorMapKey],\n              })\n\n            if (\n              // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n              currentErrorMap?.[errorMapKey] !== newErrorValue\n            ) {\n              this.setFieldMeta(field, (prev) => ({\n                ...prev,\n                errorMap: {\n                  ...prev.errorMap,\n                  [errorMapKey]: newErrorValue,\n                },\n                errorSourceMap: {\n                  ...prev.errorSourceMap,\n                  [errorMapKey]: newSource,\n                },\n              }))\n            }\n          }\n\n          this.baseStore.setState((prev) => ({\n            ...prev,\n            errorMap: {\n              ...prev.errorMap,\n              [errorMapKey]: formError,\n            },\n          }))\n\n          resolve(\n            fieldErrorsFromFormValidators\n              ? { fieldErrors: fieldErrorsFromFormValidators, errorMapKey }\n              : undefined,\n          )\n        }),\n      )\n    }\n\n    let results: ValidationPromiseResult<TFormData>[] = []\n\n    const fieldsErrorMap: FormErrorMapFromValidator<\n      TFormData,\n      TOnMount,\n      TOnChange,\n      TOnChangeAsync,\n      TOnBlur,\n      TOnBlurAsync,\n      TOnSubmit,\n      TOnSubmitAsync,\n      TOnDynamic,\n      TOnDynamicAsync\n    > = {}\n    if (promises.length) {\n      results = await Promise.all(promises)\n      for (const fieldValidationResult of results) {\n        if (fieldValidationResult?.fieldErrors) {\n          const { errorMapKey } = fieldValidationResult\n\n          for (const [field, fieldError] of Object.entries(\n            fieldValidationResult.fieldErrors,\n          )) {\n            const oldErrorMap =\n              fieldsErrorMap[field as DeepKeys<TFormData>] || {}\n            const newErrorMap = {\n              ...oldErrorMap,\n              [errorMapKey]: fieldError,\n            }\n            fieldsErrorMap[field as DeepKeys<TFormData>] = newErrorMap\n          }\n        }\n      }\n    }\n\n    this.baseStore.setState((prev) => ({\n      ...prev,\n      isFormValidating: false,\n    }))\n\n    return fieldsErrorMap\n  }\n\n  /**\n   * @private\n   */\n  validate = (\n    cause: ValidationCause,\n  ):\n    | FormErrorMapFromValidator<\n        TFormData,\n        TOnMount,\n        TOnChange,\n        TOnChangeAsync,\n        TOnBlur,\n        TOnBlurAsync,\n        TOnSubmit,\n        TOnSubmitAsync,\n        TOnDynamic,\n        TOnDynamicAsync\n      >\n    | Promise<\n        FormErrorMapFromValidator<\n          TFormData,\n          TOnMount,\n          TOnChange,\n          TOnChangeAsync,\n          TOnBlur,\n          TOnBlurAsync,\n          TOnSubmit,\n          TOnSubmitAsync,\n          TOnDynamic,\n          TOnDynamicAsync\n        >\n      > => {\n    // Attempt to sync validate first\n    const { hasErrored, fieldsErrorMap } = this.validateSync(cause)\n\n    if (hasErrored && !this.options.asyncAlways) {\n      return fieldsErrorMap\n    }\n\n    // No error? Attempt async validation\n    return this.validateAsync(cause)\n  }\n\n  /**\n   * Handles the form submission, performs validation, and calls the appropriate onSubmit or onSubmitInvalid callbacks.\n   */\n  handleSubmit(): Promise<void>\n  handleSubmit(submitMeta: TSubmitMeta): Promise<void>\n  async handleSubmit(submitMeta?: TSubmitMeta): Promise<void> {\n    this.baseStore.setState((old) => ({\n      ...old,\n      // Submission attempts mark the form as not submitted\n      isSubmitted: false,\n      // Count submission attempts\n      submissionAttempts: old.submissionAttempts + 1,\n      isSubmitSuccessful: false, // Reset isSubmitSuccessful at the start of submission\n    }))\n\n    batch(() => {\n      void (Object.values(this.fieldInfo) as FieldInfo<any>[]).forEach(\n        (field) => {\n          if (!field.instance) return\n          // If any fields are not touched\n          if (!field.instance.state.meta.isTouched) {\n            // Mark them as touched\n            field.instance.setMeta((prev) => ({ ...prev, isTouched: true }))\n          }\n        },\n      )\n    })\n\n    const submitMetaArg =\n      submitMeta ?? (this.options.onSubmitMeta as TSubmitMeta)\n\n    if (!this.state.canSubmit && !this._devtoolsSubmissionOverride) {\n      this.options.onSubmitInvalid?.({\n        value: this.state.values,\n        formApi: this,\n        meta: submitMetaArg,\n      })\n      return\n    }\n\n    this.baseStore.setState((d) => ({ ...d, isSubmitting: true }))\n\n    const done = () => {\n      this.baseStore.setState((prev) => ({ ...prev, isSubmitting: false }))\n    }\n\n    await this.validateAllFields('submit')\n\n    if (!this.state.isFieldsValid) {\n      done()\n\n      this.options.onSubmitInvalid?.({\n        value: this.state.values,\n        formApi: this,\n        meta: submitMetaArg,\n      })\n\n      formEventClient.emit('form-submission', {\n        id: this._formId,\n        submissionAttempt: this.state.submissionAttempts,\n        successful: false,\n        stage: 'validateAllFields',\n        errors: (Object.values(this.state.fieldMeta) as AnyFieldMeta[])\n          .map((meta: AnyFieldMeta) => meta.errors)\n          .flat(),\n      })\n      return\n    }\n\n    await this.validate('submit')\n\n    // Fields are invalid, do not submit\n    if (!this.state.isValid) {\n      done()\n\n      this.options.onSubmitInvalid?.({\n        value: this.state.values,\n        formApi: this,\n        meta: submitMetaArg,\n      })\n\n      formEventClient.emit('form-submission', {\n        id: this._formId,\n        submissionAttempt: this.state.submissionAttempts,\n        successful: false,\n        stage: 'validate',\n        errors: this.state.errors,\n      })\n\n      return\n    }\n\n    batch(() => {\n      void (Object.values(this.fieldInfo) as FieldInfo<TFormData>[]).forEach(\n        (field) => {\n          field.instance?.options.listeners?.onSubmit?.({\n            value: field.instance.state.value,\n            fieldApi: field.instance,\n          })\n        },\n      )\n    })\n\n    this.options.listeners?.onSubmit?.({ formApi: this, meta: submitMetaArg })\n\n    try {\n      // Run the submit code\n      await this.options.onSubmit?.({\n        value: this.state.values,\n        formApi: this,\n        meta: submitMetaArg,\n      })\n\n      batch(() => {\n        this.baseStore.setState((prev) => ({\n          ...prev,\n          isSubmitted: true,\n          isSubmitSuccessful: true, // Set isSubmitSuccessful to true on successful submission\n        }))\n\n        formEventClient.emit('form-submission', {\n          id: this._formId,\n          submissionAttempt: this.state.submissionAttempts,\n          successful: true,\n        })\n\n        done()\n      })\n    } catch (err) {\n      this.baseStore.setState((prev) => ({\n        ...prev,\n        isSubmitSuccessful: false, // Ensure isSubmitSuccessful is false if an error occurs\n      }))\n\n      formEventClient.emit('form-submission', {\n        id: this._formId,\n        submissionAttempt: this.state.submissionAttempts,\n        successful: false,\n        stage: 'inflight',\n        onError: err,\n      })\n\n      done()\n\n      throw err\n    }\n  }\n\n  /**\n   * Gets the value of the specified field.\n   */\n  getFieldValue = <TField extends DeepKeys<TFormData>>(\n    field: TField,\n  ): DeepValue<TFormData, TField> => getBy(this.state.values, field)\n\n  /**\n   * Gets the metadata of the specified field.\n   */\n  getFieldMeta = <TField extends DeepKeys<TFormData>>(\n    field: TField,\n  ): AnyFieldMeta | undefined => {\n    return this.state.fieldMeta[field]\n  }\n\n  /**\n   * Gets the field info of the specified field.\n   */\n  getFieldInfo = <TField extends DeepKeys<TFormData>>(\n    field: TField,\n  ): FieldInfo<TFormData> => {\n    // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n    return (this.fieldInfo[field] ||= {\n      instance: null,\n      validationMetaMap: {\n        onChange: undefined,\n        onBlur: undefined,\n        onSubmit: undefined,\n        onMount: undefined,\n        onServer: undefined,\n        onDynamic: undefined,\n      },\n    })\n  }\n\n  /**\n   * Updates the metadata of the specified field.\n   */\n  setFieldMeta = <TField extends DeepKeys<TFormData>>(\n    field: TField,\n    updater: Updater<AnyFieldMetaBase>,\n  ) => {\n    this.baseStore.setState((prev) => {\n      return {\n        ...prev,\n        fieldMetaBase: {\n          ...prev.fieldMetaBase,\n          [field]: functionalUpdate(\n            updater,\n            prev.fieldMetaBase[field] as never,\n          ),\n        },\n      }\n    })\n  }\n\n  /**\n   * resets every field's meta\n   */\n  resetFieldMeta = <TField extends DeepKeys<TFormData>>(\n    fieldMeta: Record<TField, AnyFieldMeta>,\n  ): Record<TField, AnyFieldMeta> => {\n    return Object.keys(fieldMeta).reduce(\n      (acc: Record<TField, AnyFieldMeta>, key) => {\n        const fieldKey = key as TField\n        acc[fieldKey] = defaultFieldMeta\n        return acc\n      },\n      {} as Record<TField, AnyFieldMeta>,\n    )\n  }\n\n  /**\n   * Sets the value of the specified field and optionally updates the touched state.\n   */\n  setFieldValue = <TField extends DeepKeys<TFormData>>(\n    field: TField,\n    updater: Updater<DeepValue<TFormData, TField>>,\n    opts?: UpdateMetaOptions,\n  ) => {\n    const dontUpdateMeta = opts?.dontUpdateMeta ?? false\n    const dontRunListeners = opts?.dontRunListeners ?? false\n    const dontValidate = opts?.dontValidate ?? false\n\n    batch(() => {\n      if (!dontUpdateMeta) {\n        this.setFieldMeta(field, (prev) => ({\n          ...prev,\n          isTouched: true,\n          isDirty: true,\n          errorMap: {\n            // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n            ...prev?.errorMap,\n            onMount: undefined,\n          },\n        }))\n      }\n\n      this.baseStore.setState((prev) => {\n        return {\n          ...prev,\n          values: setBy(prev.values, field, updater),\n        }\n      })\n    })\n\n    if (!dontRunListeners) {\n      this.getFieldInfo(field).instance?.triggerOnChangeListener()\n    }\n\n    if (!dontValidate) {\n      this.validateField(field, 'change')\n    }\n  }\n\n  deleteField = <TField extends DeepKeys<TFormData>>(field: TField) => {\n    const subFieldsToDelete = Object.keys(this.fieldInfo).filter((f) => {\n      const fieldStr = field.toString()\n      return f !== fieldStr && f.startsWith(fieldStr)\n    })\n\n    const fieldsToDelete = [...subFieldsToDelete, field]\n\n    // Cleanup the last fields\n    this.baseStore.setState((prev) => {\n      const newState = { ...prev }\n      fieldsToDelete.forEach((f) => {\n        newState.values = deleteBy(newState.values, f)\n        delete this.fieldInfo[f as never]\n        delete newState.fieldMetaBase[f as never]\n      })\n\n      return newState\n    })\n  }\n\n  /**\n   * Pushes a value into an array field.\n   */\n  pushFieldValue = <TField extends DeepKeysOfType<TFormData, any[]>>(\n    field: TField,\n    value: DeepValue<TFormData, TField> extends any[]\n      ? DeepValue<TFormData, TField>[number]\n      : never,\n    options?: UpdateMetaOptions,\n  ) => {\n    this.setFieldValue(\n      field,\n      (prev) => [...(Array.isArray(prev) ? prev : []), value] as any,\n      options,\n    )\n  }\n\n  insertFieldValue = async <TField extends DeepKeysOfType<TFormData, any[]>>(\n    field: TField,\n    index: number,\n    value: DeepValue<TFormData, TField> extends any[]\n      ? DeepValue<TFormData, TField>[number]\n      : never,\n    options?: UpdateMetaOptions,\n  ) => {\n    this.setFieldValue(\n      field,\n      (prev) => {\n        return [\n          ...(prev as DeepValue<TFormData, TField>[]).slice(0, index),\n          value,\n          ...(prev as DeepValue<TFormData, TField>[]).slice(index),\n        ] as any\n      },\n      mergeOpts(options, { dontValidate: true }),\n    )\n\n    const dontValidate = options?.dontValidate ?? false\n    if (!dontValidate) {\n      // Validate the whole array + all fields that have shifted\n      await this.validateField(field, 'change')\n    }\n\n    // Shift down all meta after validating to make sure the new field has been mounted\n    metaHelper(this).handleArrayFieldMetaShift(field, index, 'insert')\n\n    if (!dontValidate) {\n      await this.validateArrayFieldsStartingFrom(field, index, 'change')\n    }\n  }\n\n  /**\n   * Replaces a value into an array field at the specified index.\n   */\n  replaceFieldValue = async <TField extends DeepKeysOfType<TFormData, any[]>>(\n    field: TField,\n    index: number,\n    value: DeepValue<TFormData, TField> extends any[]\n      ? DeepValue<TFormData, TField>[number]\n      : never,\n    options?: UpdateMetaOptions,\n  ) => {\n    this.setFieldValue(\n      field,\n      (prev) => {\n        return (prev as DeepValue<TFormData, TField>[]).map((d, i) =>\n          i === index ? value : d,\n        ) as any\n      },\n      mergeOpts(options, { dontValidate: true }),\n    )\n\n    const dontValidate = options?.dontValidate ?? false\n    if (!dontValidate) {\n      // Validate the whole array + all fields that have shifted\n      await this.validateField(field, 'change')\n      await this.validateArrayFieldsStartingFrom(field, index, 'change')\n    }\n  }\n\n  /**\n   * Removes a value from an array field at the specified index.\n   */\n  removeFieldValue = async <TField extends DeepKeysOfType<TFormData, any[]>>(\n    field: TField,\n    index: number,\n    options?: UpdateMetaOptions,\n  ) => {\n    const fieldValue = this.getFieldValue(field)\n\n    const lastIndex = Array.isArray(fieldValue)\n      ? Math.max((fieldValue as Array<unknown>).length - 1, 0)\n      : null\n\n    this.setFieldValue(\n      field,\n      (prev) => {\n        return (prev as DeepValue<TFormData, TField>[]).filter(\n          (_d, i) => i !== index,\n        ) as any\n      },\n      mergeOpts(options, { dontValidate: true }),\n    )\n\n    // Shift up all meta\n    metaHelper(this).handleArrayFieldMetaShift(field, index, 'remove')\n\n    if (lastIndex !== null) {\n      const start = `${field}[${lastIndex}]`\n      this.deleteField(start as never)\n    }\n\n    const dontValidate = options?.dontValidate ?? false\n    if (!dontValidate) {\n      // Validate the whole array + all fields that have shifted\n      await this.validateField(field, 'change')\n      await this.validateArrayFieldsStartingFrom(field, index, 'change')\n    }\n  }\n\n  /**\n   * Swaps the values at the specified indices within an array field.\n   */\n  swapFieldValues = <TField extends DeepKeysOfType<TFormData, any[]>>(\n    field: TField,\n    index1: number,\n    index2: number,\n    options?: UpdateMetaOptions,\n  ) => {\n    this.setFieldValue(\n      field,\n      (prev: any) => {\n        const prev1 = prev[index1]!\n        const prev2 = prev[index2]!\n        return setBy(setBy(prev, `${index1}`, prev2), `${index2}`, prev1)\n      },\n      mergeOpts(options, { dontValidate: true }),\n    )\n\n    // Swap meta\n    metaHelper(this).handleArrayFieldMetaShift(field, index1, 'swap', index2)\n\n    const dontValidate = options?.dontValidate ?? false\n    if (!dontValidate) {\n      // Validate the whole array\n      this.validateField(field, 'change')\n      // Validate the swapped fields\n      this.validateField(`${field}[${index1}]` as DeepKeys<TFormData>, 'change')\n      this.validateField(`${field}[${index2}]` as DeepKeys<TFormData>, 'change')\n    }\n  }\n\n  /**\n   * Moves the value at the first specified index to the second specified index within an array field.\n   */\n  moveFieldValues = <TField extends DeepKeysOfType<TFormData, any[]>>(\n    field: TField,\n    index1: number,\n    index2: number,\n    options?: UpdateMetaOptions,\n  ) => {\n    this.setFieldValue(\n      field,\n      (prev: any) => {\n        const next: any = [...prev]\n        next.splice(index2, 0, next.splice(index1, 1)[0])\n        return next\n      },\n      mergeOpts(options, { dontValidate: true }),\n    )\n\n    // Move meta between index1 and index2\n    metaHelper(this).handleArrayFieldMetaShift(field, index1, 'move', index2)\n\n    const dontValidate = options?.dontValidate ?? false\n    if (!dontValidate) {\n      // Validate the whole array\n      this.validateField(field, 'change')\n      // Validate the moved fields\n      this.validateField(`${field}[${index1}]` as DeepKeys<TFormData>, 'change')\n      this.validateField(`${field}[${index2}]` as DeepKeys<TFormData>, 'change')\n    }\n  }\n\n  /**\n   * Clear all values within an array field.\n   */\n  clearFieldValues = <TField extends DeepKeysOfType<TFormData, any[]>>(\n    field: TField,\n    options?: UpdateMetaOptions,\n  ) => {\n    const fieldValue = this.getFieldValue(field)\n\n    const lastIndex = Array.isArray(fieldValue)\n      ? Math.max((fieldValue as unknown[]).length - 1, 0)\n      : null\n\n    this.setFieldValue(\n      field,\n      [] as any,\n      mergeOpts(options, { dontValidate: true }),\n    )\n\n    if (lastIndex !== null) {\n      for (let i = 0; i <= lastIndex; i++) {\n        const fieldKey = `${field}[${i}]`\n        this.deleteField(fieldKey as never)\n      }\n    }\n\n    const dontValidate = options?.dontValidate ?? false\n    if (!dontValidate) {\n      // validate array change\n      this.validateField(field, 'change')\n    }\n  }\n\n  /**\n   * Resets the field value and meta to default state\n   */\n  resetField = <TField extends DeepKeys<TFormData>>(field: TField) => {\n    this.baseStore.setState((prev) => {\n      return {\n        ...prev,\n        fieldMetaBase: {\n          ...prev.fieldMetaBase,\n          [field]: defaultFieldMeta,\n        },\n        values: this.options.defaultValues\n          ? setBy(prev.values, field, getBy(this.options.defaultValues, field))\n          : prev.values,\n      }\n    })\n  }\n\n  /**\n   * Updates the form's errorMap\n   */\n  setErrorMap(\n    errorMap: FormValidationErrorMap<\n      TFormData,\n      UnwrapFormValidateOrFn<TOnMount>,\n      UnwrapFormValidateOrFn<TOnChange>,\n      UnwrapFormAsyncValidateOrFn<TOnChangeAsync>,\n      UnwrapFormValidateOrFn<TOnBlur>,\n      UnwrapFormAsyncValidateOrFn<TOnBlurAsync>,\n      UnwrapFormValidateOrFn<TOnSubmit>,\n      UnwrapFormAsyncValidateOrFn<TOnSubmitAsync>,\n      UnwrapFormValidateOrFn<TOnDynamic>,\n      UnwrapFormAsyncValidateOrFn<TOnDynamicAsync>,\n      UnwrapFormAsyncValidateOrFn<TOnServer>\n    >,\n  ) {\n    batch(() => {\n      Object.entries(errorMap).forEach(([key, value]) => {\n        const errorMapKey = key as ValidationErrorMapKeys\n\n        if (isGlobalFormValidationError(value)) {\n          const { formError, fieldErrors } = normalizeError<TFormData>(value)\n\n          for (const fieldName of Object.keys(\n            this.fieldInfo,\n          ) as DeepKeys<TFormData>[]) {\n            const fieldMeta = this.getFieldMeta(fieldName)\n            if (!fieldMeta) continue\n\n            this.setFieldMeta(fieldName, (prev) => ({\n              ...prev,\n              errorMap: {\n                ...prev.errorMap,\n                [errorMapKey]: fieldErrors?.[fieldName],\n              },\n              errorSourceMap: {\n                ...prev.errorSourceMap,\n                [errorMapKey]: 'form',\n              },\n            }))\n          }\n\n          this.baseStore.setState((prev) => ({\n            ...prev,\n            errorMap: {\n              ...prev.errorMap,\n              [errorMapKey]: formError,\n            },\n          }))\n        } else {\n          this.baseStore.setState((prev) => ({\n            ...prev,\n            errorMap: {\n              ...prev.errorMap,\n              [errorMapKey]: value,\n            },\n          }))\n        }\n      })\n    })\n  }\n\n  /**\n   * Returns form and field level errors\n   */\n  getAllErrors = (): {\n    form: {\n      errors: Array<\n        | UnwrapFormValidateOrFn<TOnMount>\n        | UnwrapFormValidateOrFn<TOnChange>\n        | UnwrapFormAsyncValidateOrFn<TOnChangeAsync>\n        | UnwrapFormValidateOrFn<TOnBlur>\n        | UnwrapFormAsyncValidateOrFn<TOnBlurAsync>\n        | UnwrapFormValidateOrFn<TOnSubmit>\n        | UnwrapFormAsyncValidateOrFn<TOnSubmitAsync>\n        | UnwrapFormValidateOrFn<TOnDynamic>\n        | UnwrapFormAsyncValidateOrFn<TOnDynamicAsync>\n        | UnwrapFormAsyncValidateOrFn<TOnServer>\n      >\n      errorMap: ValidationErrorMap<\n        UnwrapFormValidateOrFn<TOnMount>,\n        UnwrapFormValidateOrFn<TOnChange>,\n        UnwrapFormAsyncValidateOrFn<TOnChangeAsync>,\n        UnwrapFormValidateOrFn<TOnBlur>,\n        UnwrapFormAsyncValidateOrFn<TOnBlurAsync>,\n        UnwrapFormValidateOrFn<TOnSubmit>,\n        UnwrapFormAsyncValidateOrFn<TOnSubmitAsync>,\n        UnwrapFormValidateOrFn<TOnDynamic>,\n        UnwrapFormAsyncValidateOrFn<TOnDynamicAsync>,\n        UnwrapFormAsyncValidateOrFn<TOnServer>\n      >\n    }\n    fields: Record<\n      DeepKeys<TFormData>,\n      { errors: ValidationError[]; errorMap: ValidationErrorMap }\n    >\n  } => {\n    return {\n      form: {\n        errors: this.state.errors,\n        errorMap: this.state.errorMap,\n      },\n      fields: Object.entries(this.state.fieldMeta).reduce(\n        (acc, [fieldName, fieldMeta]) => {\n          if (\n            Object.keys(fieldMeta as AnyFieldMeta).length &&\n            (fieldMeta as AnyFieldMeta).errors.length\n          ) {\n            acc[fieldName as DeepKeys<TFormData>] = {\n              errors: (fieldMeta as AnyFieldMeta).errors,\n              errorMap: (fieldMeta as AnyFieldMeta).errorMap,\n            }\n          }\n\n          return acc\n        },\n        {} as Record<\n          DeepKeys<TFormData>,\n          { errors: ValidationError[]; errorMap: ValidationErrorMap }\n        >,\n      ),\n    }\n  }\n\n  /**\n   * Parses the form's values with a given standard schema and returns\n   * issues (if any). This method does NOT set any internal errors.\n   * @param schema The standard schema to parse the form values with.\n   */\n  parseValuesWithSchema = (schema: StandardSchemaV1<TFormData, unknown>) => {\n    return standardSchemaValidators.validate(\n      { value: this.state.values, validationSource: 'form' },\n      schema,\n    )\n  }\n\n  /**\n   * Parses the form's values with a given standard schema and returns\n   * issues (if any). This method does NOT set any internal errors.\n   * @param schema The standard schema to parse the form values with.\n   */\n  parseValuesWithSchemaAsync = (\n    schema: StandardSchemaV1<TFormData, unknown>,\n  ) => {\n    return standardSchemaValidators.validateAsync(\n      { value: this.state.values, validationSource: 'form' },\n      schema,\n    )\n  }\n}\n\nfunction normalizeError<TFormData>(rawError?: FormValidationError<unknown>): {\n  formError: ValidationError\n  fieldErrors?: Partial<Record<DeepKeys<TFormData>, ValidationError>>\n} {\n  if (rawError) {\n    if (isGlobalFormValidationError(rawError)) {\n      const formError = normalizeError(rawError.form).formError\n      const fieldErrors = rawError.fields\n      return { formError, fieldErrors } as never\n    }\n\n    return { formError: rawError }\n  }\n\n  return { formError: undefined }\n}\n\nfunction getErrorMapKey(cause: ValidationCause) {\n  switch (cause) {\n    case 'submit':\n      return 'onSubmit'\n    case 'blur':\n      return 'onBlur'\n    case 'mount':\n      return 'onMount'\n    case 'server':\n      return 'onServer'\n    case 'dynamic':\n      return 'onDynamic'\n    case 'change':\n    default:\n      return 'onChange'\n  }\n}\n"],"names":["opts"],"mappings":";;;;;;;;;;;;;;;;;;;;AAuxBA,SAAS,oBAaP,YAAA,EA2BA;mFAKe,mFAGO,kCACA;IARtB,OAAO;QACL,6CAAqB,MAAA,gDAAb,uBAAwB,CAAA;QAChC,iDAAuB,QAAA,cAAb,6DAAyB,CAAA;QACnC,2DAA4B,aAAA,cAAb,uEAA+B,CAAA;QAC9C,uDAA0B,WAAA,iFAAe;QACzC,yDAA2B,YAAA,sDAAb,6BAA6B;QAC3C,4CAAc,aAAa,YAAA,mFAAgB;QAC3C,qEAAiC,kBAAA,+FAAsB;QACvD,qEAAiC,kBAAA,+FAAsB;QACvD,mEAAgC,iBAAA,2DAAb,kCAAkC;YACnD,UAAU,KAAA;YACV,QAAQ,KAAA;YACR,UAAU,KAAA;YACV,SAAS,KAAA;YACT,UAAU,KAAA;YACV,WAAW,KAAA;QAAA;IACb;AAEJ;AA6BO,MAAM,QAcb;IAsDE,IAAI,QAAQ;QACV,OAAO,IAAA,CAAK,KAAA,CAAM,KAAA;IACpB;IAmYA,IAAI,SAAiB;QACnB,OAAO,IAAA,CAAK,OAAA;IACd;IAAA;;GAAA,GAKA,aAKE,KAAA,EAMU;QACV,QAAI,2RAAA,EAA0B,MAAM,QAAQ,GAAG;YAC7C,OAAO,0RAAA,CAAyB,MAAM,IAAI,CAAA,CACxC,MAAM,KAAA,EACN,MAAM,QAAA;QAEV;QAEA,OAAQ,MAAM,QAAA,CAAiC,MAAM,KAAK;IAC5D;IA0oBA,MAAM,aAAa,UAAA,EAAyC;YAkG1D,kCAAA;QAjGA,IAAA,CAAK,SAAA,CAAU,QAAA,CAAS,CAAC,MAAA,CAAS;gBAChC,GAAG,GAAA;gBAAA,qDAAA;gBAEH,aAAa;gBAAA,4BAAA;gBAEb,oBAAoB,IAAI,kBAAA,GAAqB;gBAC7C,oBAAoB;YAAA,CAAA,CACpB;QAEF,IAAA,0OAAA,EAAM,MAAM;YACV,KAAM,OAAO,MAAA,CAAO,IAAA,CAAK,SAAS,EAAuB,OAAA,CACvD,CAAC,UAAU;gBACT,IAAI,CAAC,MAAM,QAAA,CAAU,CAAA;gBAErB,IAAI,CAAC,MAAM,QAAA,CAAS,KAAA,CAAM,IAAA,CAAK,SAAA,EAAW;oBAExC,MAAM,QAAA,CAAS,OAAA,CAAQ,CAAC,OAAA,CAAU;4BAAE,GAAG,IAAA;4BAAM,WAAW;wBAAA,CAAA,CAAO;gBACjE;YACF;QAEJ,CAAC;QAED,MAAM,+DACJ,aAAe,IAAA,CAAK,OAAA,CAAQ,YAAA;QAE9B,IAAI,CAAC,IAAA,CAAK,KAAA,CAAM,SAAA,IAAa,CAAC,IAAA,CAAK,2BAAA,EAA6B;gBAC9D,+BAAA;aAAA,gCAAA,CAAA,gBAAA,IAAA,CAAK,OAAA,EAAQ,eAAA,cAAb,oDAAA,mCAAA,eAA+B;gBAC7B,OAAO,IAAA,CAAK,KAAA,CAAM,MAAA;gBAClB,SAAS,IAAA;gBACT,MAAM;YAAA,CACP;YACD;QACF;QAEA,IAAA,CAAK,SAAA,CAAU,QAAA,CAAS,CAAC,IAAA,CAAO;gBAAE,GAAG,CAAA;gBAAG,cAAc;YAAA,CAAA,CAAO;QAE7D,MAAM,OAAO,MAAM;YACjB,IAAA,CAAK,SAAA,CAAU,QAAA,CAAS,CAAC,OAAA,CAAU;oBAAE,GAAG,IAAA;oBAAM,cAAc;gBAAA,CAAA,CAAQ;QACtE;QAEA,MAAM,IAAA,CAAK,iBAAA,CAAkB,QAAQ;QAErC,IAAI,CAAC,IAAA,CAAK,KAAA,CAAM,aAAA,EAAe;gBAG7B,gCAAA;YAFA,KAAA;aAEA,iCAAA,CAAA,iBAAA,IAAA,CAAK,OAAA,EAAQ,eAAA,cAAb,qDAAA,oCAAA,gBAA+B;gBAC7B,OAAO,IAAA,CAAK,KAAA,CAAM,MAAA;gBAClB,SAAS,IAAA;gBACT,MAAM;YAAA,CACP;YAED,qQAAA,CAAgB,IAAA,CAAK,mBAAmB;gBACtC,IAAI,IAAA,CAAK,OAAA;gBACT,mBAAmB,IAAA,CAAK,KAAA,CAAM,kBAAA;gBAC9B,YAAY;gBACZ,OAAO;gBACP,QAAS,OAAO,MAAA,CAAO,IAAA,CAAK,KAAA,CAAM,SAAS,EACxC,GAAA,CAAI,CAAC,OAAuB,KAAK,MAAM,EACvC,IAAA,CAAA;YAAK,CACT;YACD;QACF;QAEA,MAAM,IAAA,CAAK,QAAA,CAAS,QAAQ;QAG5B,IAAI,CAAC,IAAA,CAAK,KAAA,CAAM,OAAA,EAAS;gBAGvB,gCAAA;YAFA,KAAA;aAEA,iCAAA,CAAA,iBAAA,IAAA,CAAK,OAAA,EAAQ,eAAA,cAAb,qDAAA,oCAAA,gBAA+B;gBAC7B,OAAO,IAAA,CAAK,KAAA,CAAM,MAAA;gBAClB,SAAS,IAAA;gBACT,MAAM;YAAA,CACP;YAED,qQAAA,CAAgB,IAAA,CAAK,mBAAmB;gBACtC,IAAI,IAAA,CAAK,OAAA;gBACT,mBAAmB,IAAA,CAAK,KAAA,CAAM,kBAAA;gBAC9B,YAAY;gBACZ,OAAO;gBACP,QAAQ,IAAA,CAAK,KAAA,CAAM,MAAA;YAAA,CACpB;YAED;QACF;QAEA,IAAA,0OAAA,EAAM,MAAM;YACV,KAAM,OAAO,MAAA,CAAO,IAAA,CAAK,SAAS,EAA6B,OAAA,CAC7D,CAAC,UAAU;oBACT,4CAAA,mCAAA;iBAAA,kBAAA,MAAM,QAAA,cAAN,uCAAA,oCAAA,gBAAgB,OAAA,CAAQ,SAAA,cAAxB,yDAAA,6CAAA,kCAAmC,QAAA,cAAnC,iEAAA,gDAAA,mCAA8C;oBAC5C,OAAO,MAAM,QAAA,CAAS,KAAA,CAAM,KAAA;oBAC5B,UAAU,MAAM,QAAA;gBAAA,CACjB;YACH;QAEJ,CAAC;SAED,0BAAA,IAAA,CAAK,OAAA,CAAQ,SAAA,cAAb,+CAAA,mCAAA,wBAAwB,QAAA,cAAxB,uDAAA,sCAAA,yBAAmC;YAAE,SAAS,IAAA;YAAM,MAAM;QAAA,CAAe;QAEzE,IAAI;gBAEI;YAAN,uDAAM,CAAK,OAAA,EAAQ,QAAA,uGAAW;gBAC5B,OAAO,IAAA,CAAK,KAAA,CAAM,MAAA;gBAClB,SAAS,IAAA;gBACT,MAAM;YAAA,CACP;YAED,IAAA,0OAAA,EAAM,MAAM;gBACV,IAAA,CAAK,SAAA,CAAU,QAAA,CAAS,CAAC,OAAA,CAAU;wBACjC,GAAG,IAAA;wBACH,aAAa;wBACb,oBAAoB;oBAAA,CAAA,CACpB;gBAEF,qQAAA,CAAgB,IAAA,CAAK,mBAAmB;oBACtC,IAAI,IAAA,CAAK,OAAA;oBACT,mBAAmB,IAAA,CAAK,KAAA,CAAM,kBAAA;oBAC9B,YAAY;gBAAA,CACb;gBAED,KAAA;YACF,CAAC;QACH,EAAA,OAAS,KAAK;YACZ,IAAA,CAAK,SAAA,CAAU,QAAA,CAAS,CAAC,OAAA,CAAU;oBACjC,GAAG,IAAA;oBACH,oBAAoB;gBAAA,CAAA,CACpB;YAEF,qQAAA,CAAgB,IAAA,CAAK,mBAAmB;gBACtC,IAAI,IAAA,CAAK,OAAA;gBACT,mBAAmB,IAAA,CAAK,KAAA,CAAM,kBAAA;gBAC9B,YAAY;gBACZ,OAAO;gBACP,SAAS;YAAA,CACV;YAED,KAAA;YAEA,MAAM;QACR;IACF;IAAA;;GAAA,GAyXA,YACE,QAAA,EAaA;QACA,IAAA,0OAAA,EAAM,MAAM;YACV,OAAO,OAAA,CAAQ,QAAQ,EAAE,OAAA,CAAQ;oBAAC,CAAC,KAAK,KAAK,CAAA,KAAM;gBACjD,MAAM,cAAc;gBAEpB,QAAI,2QAAA,EAA4B,KAAK,GAAG;oBACtC,MAAM,EAAE,SAAA,EAAW,WAAA,EAAA,GAAgB,eAA0B,KAAK;oBAElE,KAAA,MAAW,aAAa,OAAO,IAAA,CAC7B,IAAA,CAAK,SAAA,EACqB;wBAC1B,MAAM,YAAY,IAAA,CAAK,YAAA,CAAa,SAAS;wBAC7C,IAAI,CAAC,UAAW,CAAA;wBAEhB,IAAA,CAAK,YAAA,CAAa,WAAW,CAAC,OAAA,CAAU;gCACtC,GAAG,IAAA;gCACH,UAAU;oCACR,GAAG,KAAK,QAAA;oCACR,CAAC,WAAW,CAAA,4DAAG,WAAA,CAAc,SAAS,CAAA;gCAAA;gCAExC,gBAAgB;oCACd,GAAG,KAAK,cAAA;oCACR,CAAC,WAAW,CAAA,EAAG;gCAAA;4BACjB,CAAA,CACA;oBACJ;oBAEA,IAAA,CAAK,SAAA,CAAU,QAAA,CAAS,CAAC,OAAA,CAAU;4BACjC,GAAG,IAAA;4BACH,UAAU;gCACR,GAAG,KAAK,QAAA;gCACR,CAAC,WAAW,CAAA,EAAG;4BAAA;wBACjB,CAAA,CACA;gBACJ,OAAO;oBACL,IAAA,CAAK,SAAA,CAAU,QAAA,CAAS,CAAC,OAAA,CAAU;4BACjC,GAAG,IAAA;4BACH,UAAU;gCACR,GAAG,KAAK,QAAA;gCACR,CAAC,WAAW,CAAA,EAAG;4BAAA;wBACjB,CAAA,CACA;gBACJ;YACF,CAAC;QACH,CAAC;IACH;IAjqDF;;GAAA,GAmFE,YACE,IAAA,CAcA;YAcmC;QA5GrC,IAAA,CAAA,OAAA,GAaI,CAAA;QAmCJ,IAAA,CAAA,SAAA,GAA+D,CAAA;QAS/D,IAAA,CAAA,kBAAA,GAAgC,CAAA,CAAA;QA2ZhC,IAAA,CAAA,KAAA,GAAQ,MAAM;gBAaZ,iCAAA;YAZA,MAAM,0BAA0B,IAAA,CAAK,gBAAA,CAAiB,KAAA,CAAA;YACtD,MAAM,sBAAsB,IAAA,CAAK,KAAA,CAAM,KAAA,CAAA;YACvC,MAAM,UAAU,MAAM;gBACpB,wBAAA;gBACA,oBAAA;gBAGA,qQAAA,CAAgB,IAAA,CAAK,kBAAkB;oBACrC,IAAI,IAAA,CAAK,OAAA;gBAAA,CACV;YACH;aAEA,0BAAA,IAAA,CAAK,OAAA,CAAQ,SAAA,cAAb,+CAAA,kCAAA,wBAAwB,OAAA,cAAxB,sDAAA,qCAAA,yBAAkC;gBAAE,SAAS,IAAA;YAAA,CAAM;YAEnD,MAAM,EAAE,OAAA,CAAA,CAAA,GAAY,IAAA,CAAK,OAAA,CAAQ,UAAA,IAAc,CAAA;YAG/C,qQAAA,CAAgB,IAAA,CAAK,YAAY;gBAC/B,IAAI,IAAA,CAAK,OAAA;gBACT,OAAO,IAAA,CAAK,KAAA,CAAM,KAAA;gBAClB,SAAS,IAAA,CAAK,OAAA;YAAA,CACf;YAGD,IAAI,CAAC,QAAS,CAAA,OAAO;YAGrB,IAAA,CAAK,YAAA,CAAa,OAAO;YACzB,OAAO;QACT;QAKA,IAAA,CAAA,MAAA,GAAS,CACP,YAcG;;YACH,IAAI,CAAC,QAAS,CAAA;YAEd,MAAM,aAAa,IAAA,CAAK,OAAA;YAGxB,IAAA,CAAK,OAAA,GAAU;YAGf,MAAM,qBAAqB,CAAC,gCAAS,SAAA,wDAAR,6CAAmB,IAAA,oFAAM,IAAA,CACpD,CAAC,KAAK,IAAM,QAAQ,IAAA,CAAK,kBAAA,CAAmB,CAAC,CAAA;YAG/C,MAAM,qBACJ,QAAQ,aAAA,IACR,KAAC,wPAAA,EAAS,QAAQ,aAAA,EAAe,WAAW,aAAa,KACzD,CAAC,IAAA,CAAK,KAAA,CAAM,SAAA;YAEd,MAAM,oBACJ,KAAC,wPAAA,EAAS,QAAQ,YAAA,EAAc,WAAW,YAAY,KACvD,CAAC,IAAA,CAAK,KAAA,CAAM,SAAA;YAEd,IAAI,CAAC,sBAAsB,CAAC,qBAAqB,CAAC,mBAAoB,CAAA;YAEtE,IAAA,0OAAA,EAAM,MAAM;gBACV,IAAA,CAAK,SAAA,CAAU,QAAA,CAAS,IACtB,oBACE,OAAO,MAAA,CACL,CAAA,GACA,IAAA,CAAK,KAAA,EAEL,oBAAoB,QAAQ,YAAA,GAAe,CAAA,GAE3C,qBACI;wBACE,QAAQ,QAAQ,aAAA;oBAAA,IAElB,CAAA,GAEJ,qBACI;wBAAE,gBAAgB,CAAC,IAAA,CAAK,KAAA,CAAM,cAAA;oBAAA,IAC9B,CAAA;YAIZ,CAAC;YAED,qQAAA,CAAgB,IAAA,CAAK,YAAY;gBAC/B,IAAI,IAAA,CAAK,OAAA;gBACT,OAAO,IAAA,CAAK,KAAA,CAAM,KAAA;gBAClB,SAAS,IAAA,CAAK,OAAA;YAAA,CACf;QACH;QASA,IAAA,CAAA,KAAA,GAAQ,CAAC,QAAoBA,UAA2C;YACtE,MAAM,EAAE,WAAW,gBAAA,CAAA,CAAA,GAAqB,IAAA,CAAK,KAAA;YAC7C,MAAM,gBAAgB,IAAA,CAAK,cAAA,CAAe,gBAAgB;YAE1D,IAAI,UAAU,oBAACA,kCAAM,iBAAA,GAAmB;gBACtC,IAAA,CAAK,OAAA,GAAU;oBACb,GAAG,IAAA,CAAK,OAAA;oBACR,eAAe;gBAAA;YAEnB;YAEA,IAAA,CAAK,SAAA,CAAU,QAAA,CAAS;;;uBACtB,oBAAoB;oBAClB,GAAI,IAAA,CAAK,OAAA,CAAQ,YAAA;oBACjB,SACE,uDACA,IAAA,CAAK,OAAA,CAAQ,aAAA,wCACb,iCAAA,CAAK,OAAA,CAAQ,YAAA,0FAAc,MAAA;oBAC7B;gBAAA,CACD;;QAEL;QAKA,IAAA,CAAA,iBAAA,GAAoB,OAAO,UAA2B;YACpD,MAAM,0BAAwD,CAAA,CAAA;YAC9D,IAAA,0OAAA,EAAM,MAAM;gBACV,KAAM,OAAO,MAAA,CAAO,IAAA,CAAK,SAAS,EAAuB,OAAA,CACvD,CAAC,UAAU;oBACT,IAAI,CAAC,MAAM,QAAA,CAAU,CAAA;oBACrB,MAAM,gBAAgB,MAAM,QAAA;oBAE5B,wBAAwB,IAAA,CAAA,+DAAA;oBAEtB,QAAQ,OAAA,GAAU,IAAA,CAAK,IACrB,cAAc,QAAA,CAAS,OAAO;4BAAE,oBAAoB;wBAAA,CAAM;oBAI9D,IAAI,CAAC,MAAM,QAAA,CAAS,KAAA,CAAM,IAAA,CAAK,SAAA,EAAW;wBAExC,MAAM,QAAA,CAAS,OAAA,CAAQ,CAAC,OAAA,CAAU;gCAAE,GAAG,IAAA;gCAAM,WAAW;4BAAA,CAAA,CAAO;oBACjE;gBACF;YAEJ,CAAC;YAED,MAAM,mBAAmB,MAAM,QAAQ,GAAA,CAAI,uBAAuB;YAClE,OAAO,iBAAiB,IAAA,CAAA;QAC1B;QAKA,IAAA,CAAA,+BAAA,GAAkC,OAGhC,OACA,OACA,UACG;YACH,MAAM,eAAe,IAAA,CAAK,aAAA,CAAc,KAAK;YAE7C,MAAM,YAAY,MAAM,OAAA,CAAQ,YAAY,IACxC,KAAK,GAAA,CAAK,aAAgC,MAAA,GAAS,GAAG,CAAC,IACvD;YAGJ,MAAM,sBAAsB,CAAC;gBAAA,UAAG,KAAK,EAAA,KAAS,OAAL,KAAK,EAAA,EAAG;aAAA;YACjD,IAAA,IAAS,IAAI,QAAQ,GAAG,KAAA,8CAAM,YAAa,CAAA,GAAI,IAAK;gBAClD,oBAAoB,IAAA,CAAK,UAAG,KAAK,EAAA,KAAK,OAAD,CAAC,EAAA,EAAG;YAC3C;YAGA,MAAM,mBAAmB,OAAO,IAAA,CAAK,IAAA,CAAK,SAAS,EAAE,MAAA,CAAO,CAAC,WAC3D,oBAAoB,IAAA,CAAK,CAAC,MAAQ,SAAS,UAAA,CAAW,GAAG,CAAC;YAI5D,MAAM,0BAAwD,CAAA,CAAA;YAC9D,IAAA,0OAAA,EAAM,MAAM;gBACV,iBAAiB,OAAA,CAAQ,CAAC,gBAAgB;oBACxC,wBAAwB,IAAA,CACtB,QAAQ,OAAA,GAAU,IAAA,CAAK,IAAM,IAAA,CAAK,aAAA,CAAc,aAAa,KAAK,CAAC;gBAEvE,CAAC;YACH,CAAC;YAED,MAAM,mBAAmB,MAAM,QAAQ,GAAA,CAAI,uBAAuB;YAClE,OAAO,iBAAiB,IAAA,CAAA;QAC1B;QAKA,IAAA,CAAA,aAAA,GAAgB,CACd,OACA,UACG;;YAEH,MAAM,6CAAgB,CAAK,SAAA,CAAU,KAAK,CAAA,0DAApB,sBAAuB,QAAA;YAC7C,IAAI,CAAC,cAAe,CAAA,OAAO,CAAA,CAAA;YAG3B,IAAI,CAAC,cAAc,KAAA,CAAM,IAAA,CAAK,SAAA,EAAW;gBAEvC,cAAc,OAAA,CAAQ,CAAC,OAAA,CAAU;wBAAE,GAAG,IAAA;wBAAM,WAAW;oBAAA,CAAA,CAAO;YAChE;YAEA,OAAO,cAAc,QAAA,CAAS,KAAK;QACrC;QAMA,IAAA,CAAA,YAAA,GAAe,CACb,UAeG;YACH,MAAM,gBAAY,qQAAA,EAAsB,OAAO;gBAC7C,GAAG,IAAA,CAAK,OAAA;gBACR,MAAM,IAAA;gBACN,iBAAiB,IAAA,CAAK,OAAA,CAAQ,eAAA,IAAmB,gRAAA;YAAA,CAClD;YAED,IAAI,aAAa;YAGjB,MAAM,4BAWF,CAAA;YAEJ,IAAA,0OAAA,EAAM,MAAM;oBA4FV,uEAAA;gBAEE,sBAkBF,uEAAA;gBAEE;gBAjHF,KAAA,MAAW,eAAe,UAAW;wBAuE/B;oBAtEJ,IAAI,CAAC,YAAY,QAAA,CAAU,CAAA;oBAE3B,MAAM,WAAW,IAAA,CAAK,YAAA,CAAa;wBACjC,UAAU,YAAY,QAAA;wBACtB,OAAO;4BACL,OAAO,IAAA,CAAK,KAAA,CAAM,MAAA;4BAClB,SAAS,IAAA;4BACT,kBAAkB;wBAAA;wBAEpB,MAAM;oBAAA,CACP;oBAED,MAAM,EAAE,SAAA,EAAW,WAAA,EAAA,GAAgB,eAA0B,QAAQ;oBAErE,MAAM,cAAc,eAAe,YAAY,KAAK;oBAEpD,KAAA,MAAW,SAAS,OAAO,IAAA,CACzB,IAAA,CAAK,KAAA,CAAM,SAAA,EACe;wBAE1B,IAAI,IAAA,CAAK,SAAA,CAAU,KAAA,CAAM,aAAA,CAAc,KAAK,CAAA,KAAM,KAAA,GAAW;4BAC3D;wBACF;wBAEA,MAAM,YAAY,IAAA,CAAK,YAAA,CAAa,KAAK;wBACzC,IAAI,CAAC,UAAW,CAAA;wBAEhB,MAAM,EACJ,UAAU,eAAA,EACV,gBAAgB,qBAAA,EAAA,GACd;wBAEJ,MAAM,kFAAwB,WAAA,CAAc,KAAK,CAAA;wBAEjD,MAAM,EAAE,aAAA,EAAe,SAAA,CAAA,CAAA,OACrB,qRAAA,EAAsC;4BACpC;4BACA,kCAAA,uEAAA;2GAEE,qBAAA,CAAwB,WAAW,CAAA,MAAM;4BAAA,uEAAA;4BAE3C,kBAAA,EAAoB,iFAAA,CAAkB,WAAW,CAAA;wBAAA,CAClD;wBAEH,IAAI,cAAc,QAAQ;4BACxB,yBAAA,CAA0B,KAAK,CAAA,GAAI;gCACjC,GAAG,yBAAA,CAA0B,KAAK,CAAA;gCAClC,CAAC,WAAW,CAAA,EAAG;4BAAA;wBAEnB;wBAEA,IAAA,uEAAA;wBAEE,kFAAA,CAAkB,WAAW,CAAA,MAAM,eACnC;4BACA,IAAA,CAAK,YAAA,CAAa,OAAO,CAAC,OAAA,CAAU;oCAClC,GAAG,IAAA;oCACH,UAAU;wCACR,GAAG,KAAK,QAAA;wCACR,CAAC,WAAW,CAAA,EAAG;oCAAA;oCAEjB,gBAAgB;wCACd,GAAG,KAAK,cAAA;wCACR,CAAC,WAAW,CAAA,EAAG;oCAAA;gCACjB,CAAA,CACA;wBACJ;oBACF;oBAGA,kCAAI,CAAK,KAAA,CAAM,QAAA,+EAAA,CAAW,WAAW,CAAA,MAAM,WAAW;wBACpD,IAAA,CAAK,SAAA,CAAU,QAAA,CAAS,CAAC,OAAA,CAAU;gCACjC,GAAG,IAAA;gCACH,UAAU;oCACR,GAAG,KAAK,QAAA;oCACR,CAAC,WAAW,CAAA,EAAG;gCAAA;4BACjB,CAAA,CACA;oBACJ;oBAEA,IAAI,aAAa,aAAa;wBAC5B,aAAa;oBACf;gBACF;gBAMA,MAAM,eAAe,eAAe,QAAQ;gBAC5C,iCAEE,CAAK,KAAA,CAAM,QAAA,6EAAA,CAAW,YAAY,CAAA,KAClC,UAAU,YACV,CAAC,YACD;oBACA,IAAA,CAAK,SAAA,CAAU,QAAA,CAAS,CAAC,OAAA,CAAU;4BACjC,GAAG,IAAA;4BACH,UAAU;gCACR,GAAG,KAAK,QAAA;gCACR,CAAC,YAAY,CAAA,EAAG,KAAA;4BAAA;wBAClB,CAAA,CACA;gBACJ;gBAMA,MAAM,eAAe,eAAe,QAAQ;gBAC5C,kCAEE,CAAK,KAAA,CAAM,QAAA,+EAAA,CAAW,YAAY,CAAA,KAClC,UAAU,YACV,CAAC,YACD;oBACA,IAAA,CAAK,SAAA,CAAU,QAAA,CAAS,CAAC,OAAA,CAAU;4BACjC,GAAG,IAAA;4BACH,UAAU;gCACR,GAAG,KAAK,QAAA;gCACR,CAAC,YAAY,CAAA,EAAG,KAAA;4BAAA;wBAClB,CAAA,CACA;gBACJ;YACF,CAAC;YAED,OAAO;gBAAE;gBAAY,gBAAgB;YAAA;QACvC;QAKA,IAAA,CAAA,aAAA,GAAgB,OACd,UAcG;YACH,MAAM,gBAAY,sQAAA,EAAuB,OAAO;gBAC9C,GAAG,IAAA,CAAK,OAAA;gBACR,MAAM,IAAA;gBACN,iBAAiB,IAAA,CAAK,OAAA,CAAQ,eAAA,IAAmB,gRAAA;YAAA,CAClD;YAED,IAAI,CAAC,IAAA,CAAK,KAAA,CAAM,gBAAA,EAAkB;gBAChC,IAAA,CAAK,SAAA,CAAU,QAAA,CAAS,CAAC,OAAA,CAAU;wBAAE,GAAG,IAAA;wBAAM,kBAAkB;oBAAA,CAAA,CAAO;YACzE;YAMA,MAAM,WAA0D,CAAA,CAAA;YAEhE,IAAI;YAIJ,KAAA,MAAW,eAAe,UAAW;gBACnC,IAAI,CAAC,YAAY,QAAA,CAAU,CAAA;gBAC3B,MAAM,MAAM,eAAe,YAAY,KAAK;gBAC5C,MAAM,qBAAqB,IAAA,CAAK,KAAA,CAAM,iBAAA,CAAkB,GAAG,CAAA;gBAE3D,+BAAA,yCAAA,mBAAoB,mBAAA,CAAoB,KAAA,CAAA;gBACxC,MAAM,aAAa,IAAI,gBAAA;gBAEvB,IAAA,CAAK,KAAA,CAAM,iBAAA,CAAkB,GAAG,CAAA,GAAI;oBAClC,qBAAqB;gBAAA;gBAGvB,SAAS,IAAA,CACP,IAAI,QAA4C,OAAO,YAAY;oBACjE,IAAI;oBAIJ,IAAI;wBACF,WAAW,MAAM,IAAI,QAAQ,CAAC,YAAY,cAAc;4BACtD,WAAW,YAAY;gCACrB,IAAI,WAAW,MAAA,CAAO,OAAA,CAAS,CAAA,OAAO,WAAW,KAAA,CAAS;gCAC1D,IAAI;oCACF,WACE,MAAM,IAAA,CAAK,YAAA,CAAa;wCACtB,UAAU,YAAY,QAAA;wCACtB,OAAO;4CACL,OAAO,IAAA,CAAK,KAAA,CAAM,MAAA;4CAClB,SAAS,IAAA;4CACT,kBAAkB;4CAClB,QAAQ,WAAW,MAAA;wCAAA;wCAErB,MAAM;oCAAA,CACP;gCAEL,EAAA,OAAS,GAAG;oCACV,UAAU,CAAC;gCACb;4BACF,GAAG,YAAY,UAAU;wBAC3B,CAAC;oBACH,EAAA,OAAS,GAAY;wBACnB,WAAW;oBACb;oBACA,MAAM,EAAE,SAAA,EAAW,aAAa,6BAAA,CAAA,CAAA,GAC9B,eAA0B,QAAQ;oBAEpC,IAAI,+BAA+B;wBACjC,gCAAgC,gCAC5B;4BACE,GAAG,6BAAA;4BACH,GAAG,6BAAA;wBAAA,IAEL;oBACN;oBACA,MAAM,cAAc,eAAe,YAAY,KAAK;oBAEpD,KAAA,MAAW,SAAS,OAAO,IAAA,CACzB,IAAA,CAAK,KAAA,CAAM,SAAA,EACe;wBAE1B,IAAI,IAAA,CAAK,SAAA,CAAU,KAAA,CAAM,aAAA,CAAc,KAAK,CAAA,KAAM,KAAA,GAAW;4BAC3D;wBACF;wBAEA,MAAM,YAAY,IAAA,CAAK,YAAA,CAAa,KAAK;wBACzC,IAAI,CAAC,UAAW,CAAA;wBAEhB,MAAM,EACJ,UAAU,eAAA,EACV,gBAAgB,qBAAA,EAAA,GACd;wBAEJ,MAAM,sHAAwB,6BAAA,CAAgC,KAAK,CAAA;wBAEnE,MAAM,EAAE,aAAA,EAAe,SAAA,CAAA,CAAA,OACrB,qRAAA,EAAsC;4BACpC;4BACA,kCAAA,uEAAA;4BAEE,oGAAA,CAAwB,WAAW,CAAA,MAAM;4BAAA,uEAAA;4BAE3C,kBAAA,oEAAoB,eAAA,CAAkB,WAAW,CAAA;wBAAA,CAClD;wBAEH,IAAA,uEAAA;2FAEE,eAAA,CAAkB,WAAW,CAAA,MAAM,eACnC;4BACA,IAAA,CAAK,YAAA,CAAa,OAAO,CAAC,OAAA,CAAU;oCAClC,GAAG,IAAA;oCACH,UAAU;wCACR,GAAG,KAAK,QAAA;wCACR,CAAC,WAAW,CAAA,EAAG;oCAAA;oCAEjB,gBAAgB;wCACd,GAAG,KAAK,cAAA;wCACR,CAAC,WAAW,CAAA,EAAG;oCAAA;gCACjB,CAAA,CACA;wBACJ;oBACF;oBAEA,IAAA,CAAK,SAAA,CAAU,QAAA,CAAS,CAAC,OAAA,CAAU;4BACjC,GAAG,IAAA;4BACH,UAAU;gCACR,GAAG,KAAK,QAAA;gCACR,CAAC,WAAW,CAAA,EAAG;4BAAA;wBACjB,CAAA,CACA;oBAEF,QACE,gCACI;wBAAE,aAAa;wBAA+B;oBAAA,IAC9C,KAAA;gBAER,CAAC;YAEL;YAEA,IAAI,UAAgD,CAAA,CAAA;YAEpD,MAAM,iBAWF,CAAA;YACJ,IAAI,SAAS,MAAA,EAAQ;gBACnB,UAAU,MAAM,QAAQ,GAAA,CAAI,QAAQ;gBACpC,KAAA,MAAW,yBAAyB,QAAS;oBAC3C,kFAAI,sBAAuB,WAAA,EAAa;wBACtC,MAAM,EAAE,WAAA,EAAA,GAAgB;wBAExB,KAAA,MAAW,CAAC,OAAO,UAAU,CAAA,IAAK,OAAO,OAAA,CACvC,sBAAsB,WAAA,EACrB;4BACD,MAAM,cACJ,cAAA,CAAe,KAA4B,CAAA,IAAK,CAAA;4BAClD,MAAM,cAAc;gCAClB,GAAG,WAAA;gCACH,CAAC,WAAW,CAAA,EAAG;4BAAA;4BAEjB,cAAA,CAAe,KAA4B,CAAA,GAAI;wBACjD;oBACF;gBACF;YACF;YAEA,IAAA,CAAK,SAAA,CAAU,QAAA,CAAS,CAAC,OAAA,CAAU;oBACjC,GAAG,IAAA;oBACH,kBAAkB;gBAAA,CAAA,CAClB;YAEF,OAAO;QACT;QAKA,IAAA,CAAA,QAAA,GAAW,CACT,UA2BO;YAEP,MAAM,EAAE,UAAA,EAAY,cAAA,CAAA,CAAA,GAAmB,IAAA,CAAK,YAAA,CAAa,KAAK;YAE9D,IAAI,cAAc,CAAC,IAAA,CAAK,OAAA,CAAQ,WAAA,EAAa;gBAC3C,OAAO;YACT;YAGA,OAAO,IAAA,CAAK,aAAA,CAAc,KAAK;QACjC;QAyJA,IAAA,CAAA,aAAA,GAAgB,CACd,YACiC,qPAAA,EAAM,IAAA,CAAK,KAAA,CAAM,MAAA,EAAQ,KAAK;QAKjE,IAAA,CAAA,YAAA,GAAe,CACb,UAC6B;YAC7B,OAAO,IAAA,CAAK,KAAA,CAAM,SAAA,CAAU,KAAK,CAAA;QACnC;QAKA,IAAA,CAAA,YAAA,GAAe,CACb,UACyB;;YAEzB,8BAAQ,CAAK,SAAA,CAAA,UAAU,KAAK,CAAA,KAApB,eAAK,QAAe,GAAM;gBAChC,UAAU;gBACV,mBAAmB;oBACjB,UAAU,KAAA;oBACV,QAAQ,KAAA;oBACR,UAAU,KAAA;oBACV,SAAS,KAAA;oBACT,UAAU,KAAA;oBACV,WAAW,KAAA;gBAAA;YACb;QAEJ;QAKA,IAAA,CAAA,YAAA,GAAe,CACb,OACA,YACG;YACH,IAAA,CAAK,SAAA,CAAU,QAAA,CAAS,CAAC,SAAS;gBAChC,OAAO;oBACL,GAAG,IAAA;oBACH,eAAe;wBACb,GAAG,KAAK,aAAA;wBACR,CAAC,KAAK,CAAA,MAAG,gQAAA,EACP,SACA,KAAK,aAAA,CAAc,KAAK,CAAA;oBAC1B;gBACF;YAEJ,CAAC;QACH;QAKA,IAAA,CAAA,cAAA,GAAiB,CACf,cACiC;YACjC,OAAO,OAAO,IAAA,CAAK,SAAS,EAAE,MAAA,CAC5B,CAAC,KAAmC,QAAQ;gBAC1C,MAAM,WAAW;gBACjB,GAAA,CAAI,QAAQ,CAAA,GAAI,qQAAA;gBAChB,OAAO;YACT,GACA,CAAA;QAEJ;QAKA,IAAA,CAAA,aAAA,GAAgB,CACd,OACA,SACAA,UACG;;YACH,MAAM,0CAAiBA,oDAAM,cAAA,yEAAkB;;YAC/C,MAAM,kGAAyB,gBAAA,mDAANA,0BAA0B;;YACnD,MAAM,sCAAeA,oDAAM,YAAA,qEAAgB;YAE3C,IAAA,0OAAA,EAAM,MAAM;gBACV,IAAI,CAAC,gBAAgB;oBACnB,IAAA,CAAK,YAAA,CAAa,OAAO,CAAC,OAAA,CAAU;4BAClC,GAAG,IAAA;4BACH,WAAW;4BACX,SAAS;4BACT,UAAU;+EAEL,KAAM,QAAT,AAAS;gCACT,SAAS,KAAA;4BAAA;wBACX,CAAA,CACA;gBACJ;gBAEA,IAAA,CAAK,SAAA,CAAU,QAAA,CAAS,CAAC,SAAS;oBAChC,OAAO;wBACL,GAAG,IAAA;wBACH,YAAQ,qPAAA,EAAM,KAAK,MAAA,EAAQ,OAAO,OAAO;oBAAA;gBAE7C,CAAC;YACH,CAAC;YAED,IAAI,CAAC,kBAAkB;oBACrB;iBAAA,8BAAA,IAAA,CAAK,YAAA,CAAa,KAAK,EAAE,QAAA,cAAzB,kDAAA,4BAAmC,uBAAA,CAAA;YACrC;YAEA,IAAI,CAAC,cAAc;gBACjB,IAAA,CAAK,aAAA,CAAc,OAAO,QAAQ;YACpC;QACF;QAEA,IAAA,CAAA,WAAA,GAAc,CAAqC,UAAkB;YACnE,MAAM,oBAAoB,OAAO,IAAA,CAAK,IAAA,CAAK,SAAS,EAAE,MAAA,CAAO,CAAC,MAAM;gBAClE,MAAM,WAAW,MAAM,QAAA,CAAA;gBACvB,OAAO,MAAM,YAAY,EAAE,UAAA,CAAW,QAAQ;YAChD,CAAC;YAED,MAAM,iBAAiB,CAAC;mBAAG;gBAAmB,KAAK;aAAA;YAGnD,IAAA,CAAK,SAAA,CAAU,QAAA,CAAS,CAAC,SAAS;gBAChC,MAAM,WAAW;oBAAE,GAAG,IAAA;gBAAA;gBACtB,eAAe,OAAA,CAAQ,CAAC,MAAM;oBAC5B,SAAS,MAAA,GAAS,4PAAA,EAAS,SAAS,MAAA,EAAQ,CAAC;oBAC7C,OAAO,IAAA,CAAK,SAAA,CAAU,CAAU,CAAA;oBAChC,OAAO,SAAS,aAAA,CAAc,CAAU,CAAA;gBAC1C,CAAC;gBAED,OAAO;YACT,CAAC;QACH;QAKA,IAAA,CAAA,cAAA,GAAiB,CACf,OACA,OAGA,YACG;YACH,IAAA,CAAK,aAAA,CACH,OACA,CAAC,OAAS,CAAC;uBAAI,MAAM,OAAA,CAAQ,IAAI,IAAI,OAAO,CAAA,CAAA;oBAAK,KAAK;iBAAA,EACtD;QAEJ;QAEA,IAAA,CAAA,gBAAA,GAAmB,OACjB,OACA,OACA,OAGA,YACG;YACH,IAAA,CAAK,aAAA,CACH,OACA,CAAC,SAAS;gBACR,OAAO;uBACD,KAAwC,KAAA,CAAM,GAAG,KAAK;oBAC1D;uBACI,KAAwC,KAAA,CAAM,KAAK;iBAAA;YAE3D,OACA,yPAAA,EAAU,SAAS;gBAAE,cAAc;YAAA,CAAM;gBAGtB;YAArB,MAAM,kGAAwB,YAAA,yEAAgB;YAC9C,IAAI,CAAC,cAAc;gBAEjB,MAAM,IAAA,CAAK,aAAA,CAAc,OAAO,QAAQ;YAC1C;YAGA,IAAA,+PAAA,EAAW,IAAI,EAAE,yBAAA,CAA0B,OAAO,OAAO,QAAQ;YAEjE,IAAI,CAAC,cAAc;gBACjB,MAAM,IAAA,CAAK,+BAAA,CAAgC,OAAO,OAAO,QAAQ;YACnE;QACF;QAKA,IAAA,CAAA,iBAAA,GAAoB,OAClB,OACA,OACA,OAGA,YACG;YACH,IAAA,CAAK,aAAA,CACH,OACA,CAAC,SAAS;gBACR,OAAQ,KAAwC,GAAA,CAAI,CAAC,GAAG,IACtD,MAAM,QAAQ,QAAQ;YAE1B,OACA,yPAAA,EAAU,SAAS;gBAAE,cAAc;YAAA,CAAM;;YAG3C,MAAM,kGAAwB,YAAA,iDAAT,wBAAyB;YAC9C,IAAI,CAAC,cAAc;gBAEjB,MAAM,IAAA,CAAK,aAAA,CAAc,OAAO,QAAQ;gBACxC,MAAM,IAAA,CAAK,+BAAA,CAAgC,OAAO,OAAO,QAAQ;YACnE;QACF;QAKA,IAAA,CAAA,gBAAA,GAAmB,OACjB,OACA,OACA,YACG;YACH,MAAM,aAAa,IAAA,CAAK,aAAA,CAAc,KAAK;YAE3C,MAAM,YAAY,MAAM,OAAA,CAAQ,UAAU,IACtC,KAAK,GAAA,CAAK,WAA8B,MAAA,GAAS,GAAG,CAAC,IACrD;YAEJ,IAAA,CAAK,aAAA,CACH,OACA,CAAC,SAAS;gBACR,OAAQ,KAAwC,MAAA,CAC9C,CAAC,IAAI,IAAM,MAAM;YAErB,OACA,yPAAA,EAAU,SAAS;gBAAE,cAAc;YAAA,CAAM;YAI3C,IAAA,+PAAA,EAAW,IAAI,EAAE,yBAAA,CAA0B,OAAO,OAAO,QAAQ;YAEjE,IAAI,cAAc,MAAM;gBACtB,MAAM,QAAQ,UAAG,KAAK,EAAA,KAAa,OAAT,SAAS,EAAA;gBACnC,IAAA,CAAK,WAAA,CAAY,KAAc;YACjC;;YAEA,MAAM,kGAAwB,YAAA,iDAAT,wBAAyB;YAC9C,IAAI,CAAC,cAAc;gBAEjB,MAAM,IAAA,CAAK,aAAA,CAAc,OAAO,QAAQ;gBACxC,MAAM,IAAA,CAAK,+BAAA,CAAgC,OAAO,OAAO,QAAQ;YACnE;QACF;QAKA,IAAA,CAAA,eAAA,GAAkB,CAChB,OACA,QACA,QACA,YACG;YACH,IAAA,CAAK,aAAA,CACH,OACA,CAAC,SAAc;gBACb,MAAM,QAAQ,IAAA,CAAK,MAAM,CAAA;gBACzB,MAAM,QAAQ,IAAA,CAAK,MAAM,CAAA;gBACzB,WAAO,qPAAA,MAAM,qPAAA,EAAM,MAAM,GAAS,OAAN,MAAM,GAAI,KAAK,GAAG,GAAS,OAAN,MAAM,GAAI,KAAK;YAClE,GACA,6PAAA,EAAU,SAAS;gBAAE,cAAc;YAAA,CAAM;YAI3C,IAAA,+PAAA,EAAW,IAAI,EAAE,yBAAA,CAA0B,OAAO,QAAQ,QAAQ,MAAM;;YAExE,MAAM,kGAAwB,YAAA,iDAAT,wBAAyB;YAC9C,IAAI,CAAC,cAAc;gBAEjB,IAAA,CAAK,aAAA,CAAc,OAAO,QAAQ;gBAElC,IAAA,CAAK,aAAA,CAAc,UAAG,KAAK,EAAA,KAAU,OAAN,MAAM,EAAA,MAA4B,QAAQ;gBACzE,IAAA,CAAK,aAAA,CAAc,GAAY,MAAM,CAAf,KAAK,EAAA,KAAU,eAAA,MAA4B,QAAQ;YAC3E;QACF;QAKA,IAAA,CAAA,eAAA,GAAkB,CAChB,OACA,QACA,QACA,YACG;YACH,IAAA,CAAK,aAAA,CACH,OACA,CAAC,SAAc;gBACb,MAAM,OAAY,CAAC;uBAAG,IAAI;iBAAA;gBAC1B,KAAK,MAAA,CAAO,QAAQ,GAAG,KAAK,MAAA,CAAO,QAAQ,CAAC,CAAA,CAAE,CAAC,CAAC;gBAChD,OAAO;YACT,OACA,yPAAA,EAAU,SAAS;gBAAE,cAAc;YAAA,CAAM;YAI3C,IAAA,+PAAA,EAAW,IAAI,EAAE,yBAAA,CAA0B,OAAO,QAAQ,QAAQ,MAAM;;YAExE,MAAM,kGAAwB,YAAA,iDAAT,wBAAyB;YAC9C,IAAI,CAAC,cAAc;gBAEjB,IAAA,CAAK,aAAA,CAAc,OAAO,QAAQ;gBAElC,IAAA,CAAK,aAAA,CAAc,UAAG,KAAK,EAAA,KAAU,OAAN,MAAM,EAAA,MAA4B,QAAQ;gBACzE,IAAA,CAAK,aAAA,CAAc,UAAG,KAAK,EAAA,KAAU,OAAN,MAAM,EAAA,MAA4B,QAAQ;YAC3E;QACF;QAKA,IAAA,CAAA,gBAAA,GAAmB,CACjB,OACA,YACG;YACH,MAAM,aAAa,IAAA,CAAK,aAAA,CAAc,KAAK;YAE3C,MAAM,YAAY,MAAM,OAAA,CAAQ,UAAU,IACtC,KAAK,GAAA,CAAK,WAAyB,MAAA,GAAS,GAAG,CAAC,IAChD;YAEJ,IAAA,CAAK,aAAA,CACH,OACA,CAAA,CAAA,MACA,yPAAA,EAAU,SAAS;gBAAE,cAAc;YAAA,CAAM;YAG3C,IAAI,cAAc,MAAM;gBACtB,IAAA,IAAS,IAAI,GAAG,KAAK,WAAW,IAAK;oBACnC,MAAM,WAAW,UAAG,KAAK,EAAA,KAAK,OAAD,CAAC,EAAA;oBAC9B,IAAA,CAAK,WAAA,CAAY,QAAiB;gBACpC;YACF;gBAEqB;YAArB,MAAM,kGAAwB,YAAA,yEAAgB;YAC9C,IAAI,CAAC,cAAc;gBAEjB,IAAA,CAAK,aAAA,CAAc,OAAO,QAAQ;YACpC;QACF;QAKA,IAAA,CAAA,UAAA,GAAa,CAAqC,UAAkB;YAClE,IAAA,CAAK,SAAA,CAAU,QAAA,CAAS,CAAC,SAAS;gBAChC,OAAO;oBACL,GAAG,IAAA;oBACH,eAAe;wBACb,GAAG,KAAK,aAAA;wBACR,CAAC,KAAK,CAAA,EAAG,qQAAA;oBAAA;oBAEX,QAAQ,IAAA,CAAK,OAAA,CAAQ,aAAA,GACjB,yPAAA,EAAM,KAAK,MAAA,EAAQ,WAAO,qPAAA,EAAM,IAAA,CAAK,OAAA,CAAQ,aAAA,EAAe,KAAK,CAAC,IAClE,KAAK,MAAA;gBAAA;YAEb,CAAC;QACH;QAqEA,IAAA,CAAA,YAAA,GAAe,MA+BV;YACH,OAAO;gBACL,MAAM;oBACJ,QAAQ,IAAA,CAAK,KAAA,CAAM,MAAA;oBACnB,UAAU,IAAA,CAAK,KAAA,CAAM,QAAA;gBAAA;gBAEvB,QAAQ,OAAO,OAAA,CAAQ,IAAA,CAAK,KAAA,CAAM,SAAS,EAAE,MAAA,CAC3C,CAAC;wBAAK,CAAC,WAAW,SAAS,CAAA,KAAM;oBAC/B,IACE,OAAO,IAAA,CAAK,SAAyB,EAAE,MAAA,IACtC,UAA2B,MAAA,CAAO,MAAA,EACnC;wBACA,GAAA,CAAI,SAAgC,CAAA,GAAI;4BACtC,QAAS,UAA2B,MAAA;4BACpC,UAAW,UAA2B,QAAA;wBAAA;oBAE1C;oBAEA,OAAO;gBACT,GACA,CAAA;YAIF;QAEJ;QAOA,IAAA,CAAA,qBAAA,GAAwB,CAAC,WAAiD;YACxE,OAAO,0RAAA,CAAyB,QAAA,CAC9B;gBAAE,OAAO,IAAA,CAAK,KAAA,CAAM,MAAA;gBAAQ,kBAAkB;YAAA,GAC9C;QAEJ;QAOA,IAAA,CAAA,0BAAA,GAA6B,CAC3B,WACG;YACH,OAAO,0RAAA,CAAyB,aAAA,CAC9B;gBAAE,OAAO,IAAA,CAAK,KAAA,CAAM,MAAA;gBAAQ,kBAAkB;YAAA,GAC9C;QAEJ;QAtpDE,IAAA,CAAK,UAAA,GAAa;YAChB,aAAa,CAAA;YACb,WAAW,CAAA;YACX,eAAe,CAAA;QAAC;;QAGlB,IAAA,CAAK,OAAA,oEAAgB,MAAA,wCAAN,eAAgB,wPAAA,CAAA;QAE/B,IAAA,CAAK,2BAAA,GAA8B;YAKvB;QAHZ,IAAA,CAAK,SAAA,GAAY,IAAI,sOAAA,CACnB,oBAAoB;2DACd,KAAM,YAAV,AAAU;YACV,gFAAc,aAAA,4IAAuB,YAAA,0EAAc,MAAA;QAErD,CAAC;QAGH,IAAA,CAAK,gBAAA,GAAmB,IAAI,0OAAA,CAAQ;YAClC,MAAM;gBAAC,IAAA,CAAK,SAAS;aAAA;YACrB,IAAI;oBAAC,EAAE,WAAA,EAAa,WAAA,EAAa,SAAS,QAAA,EAAA,KAAe;gBACvD,MAAM,UAAU;gBAGhB,MAAM,0EAAgB,WAAA,CAAc,CAAC,CAAA;gBACrC,MAAM,gBAAgB,WAAA,CAAY,CAAC,CAAA;gBAEnC,IAAI,oBAAoB;gBAExB,MAAM,YAAY,CAAA;gBAclB,KAAA,MAAW,aAAa,OAAO,IAAA,CAC7B,cAAc,aAAA,EACsC;wBA2ChD,uEAAA;oBAEA;oBA5CJ,MAAM,eAAe,cAAc,aAAA,CACjC,SACF,CAAA;oBAEA,MAAM,6EAAe,cAAe,aAAA,CAClC,SACF,CAAA;oBAEA,MAAM,kEACJ,OAAA,CAAU,SAA0C,CAAA;oBAEtD,MAAM,kBAAc,qPAAA,EAAM,cAAc,MAAA,EAAQ,SAAS;oBAEzD,IAAI,4EAAc,cAAe,MAAA;oBACjC,IACE,CAAC,gBACD,aAAa,QAAA,KAAa,aAAa,QAAA,EACvC;4BAOsB;;wBALtB,cAAc,OAAO,MAAA,wCAAoB,QAAA,kDAAb,yBAAyB,CAAA,CAAE,EAAE,MAAA,CACvD,CAAC,MAAQ,QAAQ,KAAA;wBAInB,MAAM,2CAAgB,CAAK,YAAA,CAAa,SAAS,6EAAG,QAAA;wBAEpD,IAAI,iBAAiB,CAAC,cAAc,OAAA,CAAQ,gBAAA,EAAkB;4BAC5D,wEAAe,YAAsC,IAAA,CACnD;wBAEJ;oBACF;oBAGA,MAAM,eAAe,KAAC,+PAAA,mDAAgB,cAAe,CAAA,CAAE;oBACvD,MAAM,kBAAkB,CAAC,aAAa,OAAA;oBACtC,MAAM,iBACJ,4PAAA,EACE,iBACA,qPAAA,EAAM,IAAA,CAAK,OAAA,CAAQ,aAAA,EAAe,SAAS,UAE7C,wPAAA,EACE,uCAEA,CAAK,YAAA,CAAa,SAAS,0GAAG,QAAA,4FAAU,OAAA,CAAQ,YAAA;oBAGpD,IACE,iBACA,cAAc,UAAA,KAAe,mBAC7B,cAAc,OAAA,KAAY,gBAC1B,cAAc,cAAA,KAAmB,kBACjC,cAAc,MAAA,KAAW,eACzB,iBAAiB,cACjB;wBACA,SAAA,CAAU,SAAS,CAAA,GAAI;wBACvB;wBACA;oBACF;oBAEA,SAAA,CAAU,SAAS,CAAA,GAAI;wBACrB,GAAG,YAAA;wBACH,QAAQ;wBACR,YAAY;wBACZ,SAAS;wBACT;oBAAA;gBAEJ;gBAEA,IAAI,CAAC,OAAO,IAAA,CAAK,cAAc,aAAa,EAAE,MAAA,CAAQ,CAAA,OAAO;gBAE7D,IACE,WACA,sBAAsB,OAAO,IAAA,CAAK,cAAc,aAAa,EAAE,MAAA,EAC/D;oBACA,OAAO;gBACT;gBAEA,OAAO;YACT;QAAA,CACD;QAED,IAAA,CAAK,KAAA,GAAQ,IAAI,0OAAA,CAAQ;YACvB,MAAM;gBAAC,IAAA,CAAK,SAAA;gBAAW,IAAA,CAAK,gBAAgB;aAAA;YAC5C,IAAI;oBAAC,EAAE,WAAA,EAAa,WAAA,EAAa,SAAS,QAAA,EAAA,KAAe;6CA4C/B,uEAAA;0CA2GD;gBAtJvB,MAAM,UAAU;gBAehB,MAAM,gBAAgB,qEAAA,CAAc,CAAC,CAAA;gBACrC,MAAM,gBAAgB,WAAA,CAAY,CAAC,CAAA;gBACnC,MAAM,gBAAgB,WAAA,CAAY,CAAC,CAAA;gBAGnC,MAAM,kBAAkB,OAAO,MAAA,CAAO,aAAa,EAAE,MAAA,CACnD;gBAGF,MAAM,qBAAqB,gBAAgB,IAAA,CACzC,CAAC,QAAU,MAAM,YAAA;gBAGnB,MAAM,gBAAgB,gBAAgB,KAAA,CAAM,CAAC,QAAU,MAAM,OAAO;gBAEpE,MAAM,YAAY,gBAAgB,IAAA,CAAK,CAAC,QAAU,MAAM,SAAS;gBACjE,MAAM,YAAY,gBAAgB,IAAA,CAAK,CAAC,QAAU,MAAM,SAAS;gBACjE,MAAM,iBAAiB,gBAAgB,KAAA,CACrC,CAAC,QAAU,MAAM,cAAA;gBAGnB,MAAM,0BAAA,uEAAA;gBAEJ,uDAA2B,QAAA,4DAAd,wBAAwB,OAAA;gBAEvC,MAAM,UAAU,gBAAgB,IAAA,CAAK,CAAC,QAAU,MAAM,OAAO;gBAC7D,MAAM,aAAa,CAAC;gBAEpB,MAAM,kBAAkB,QAEtB,2CAAc,QAAA,sFAAU,OAAA,KAAA,uEAAA;gBAEtB,gBAAgB,IAAA,CAAK,CAAC;wBAAM;kFAAG,QAAA,4DAAU,OAAO;;gBAGpD,MAAM,eAAe,CAAC,CAAC;;gBAGvB,IAAI,sFAAkB,MAAA,2CAAT,kBAAmB,CAAA,CAAA;gBAChC,IACE,CAAC,iBACD,cAAc,QAAA,KAAa,cAAc,QAAA,EACzC;oBACA,SAAS,OAAO,MAAA,CAAO,cAAc,QAAQ,EAAE,MAAA,CAW7C,CAAC,MAAM,SAAS;wBAChB,IAAI,SAAS,KAAA,EAAW,CAAA,OAAO;wBAE/B,IAAI,YAAQ,2QAAA,EAA4B,IAAI,GAAG;4BAC7C,KAAK,IAAA,CAAK,KAAK,IAAa;4BAC5B,OAAO;wBACT;wBACA,KAAK,IAAA,CAAK,IAAa;wBACvB,OAAO;oBACT,GAAG,CAAA,CAAE;gBACP;gBAEA,MAAM,cAAc,OAAO,MAAA,KAAW;gBACtC,MAAM,UAAU,iBAAiB;;gBACjC,MAAM,gBAAgB,0CAAA,CAAK,OAAA,CAAQ,oBAAA,mGAAwB;gBAC3D,MAAM,YACH,cAAc,kBAAA,KAAuB,KACpC,CAAC,aACD,CAAC,mBACF,CAAC,gBAAgB,CAAC,cAAc,YAAA,IAAgB,WACjD;gBAEF,IAAI,WAAW,cAAc,QAAA;gBAC7B,IAAI,yBAAyB;oBAC3B,SAAS,OAAO,MAAA,CACd,CAAC,MAAQ,QAAQ,cAAc,QAAA,CAAS,OAAA;oBAE1C,WAAW,OAAO,MAAA,CAAO,UAAU;wBAAE,SAAS,KAAA;oBAAA,CAAW;gBAC3D;gBAEA,IACE,WACA,iBACA,QAAQ,QAAA,KAAa,YACrB,QAAQ,SAAA,KAAc,IAAA,CAAK,gBAAA,CAAiB,KAAA,IAC5C,QAAQ,MAAA,KAAW,UACnB,QAAQ,kBAAA,KAAuB,sBAC/B,QAAQ,aAAA,KAAkB,iBAC1B,QAAQ,WAAA,KAAgB,eACxB,QAAQ,OAAA,KAAY,WACpB,QAAQ,SAAA,KAAc,aACtB,QAAQ,SAAA,KAAc,aACtB,QAAQ,SAAA,KAAc,aACtB,QAAQ,UAAA,KAAe,cACvB,QAAQ,cAAA,KAAmB,kBAC3B,QAAQ,OAAA,KAAY,WACpB,4PAAA,EAAS,eAAe,aAAa,GACrC;oBACA,OAAO;gBACT;gBAEA,IAAI,QAAQ;oBACV,GAAG,aAAA;oBACH;oBACA,WAAW,IAAA,CAAK,gBAAA,CAAiB,KAAA;oBACjC;oBACA;oBACA;oBACA;oBACA;oBACA;oBACA;oBACA;oBACA;oBACA;oBACA;gBAAA;;gBAgBF,MAAM,gFAAiB,CAAK,OAAA,CAAQ,SAAA,oFAAW,IAAA,uFAAQ,CAAA,CAAA;gBACvD,MAAM,kBACJ,eAAe,MAAA,KAAW,IAAA,CAAK,kBAAA,CAAmB,MAAA,IAClD,eAAe,IAAA,CAAK,CAAC,KAAK,IAAM,QAAQ,IAAA,CAAK,kBAAA,CAAmB,CAAC,CAAC;gBAEpE,IAAI,iBAAiB;wBAGnB;oBAFA,MAAM,SAAS,OAAO,MAAA,CAAO,CAAA,GAAI,IAAA,EAAM;wBAAE;oBAAA,CAAO;qBAEhD,2BAAA,IAAA,CAAK,OAAA,CAAQ,SAAA,cAAb,+CAAA,yBAAwB,EAAA,CAAG,MAAM;oBACjC,QAAQ,OAAO,KAAA;oBACf,IAAA,CAAK,kBAAA,GAAqB;gBAC5B;gBAEA,OAAO;YACT;QAAA,CACD;QAED,IAAA,CAAK,YAAA,GAAe,IAAA,CAAK,YAAA,CAAa,IAAA,CAAK,IAAI;QAE/C,IAAA,CAAK,MAAA,CAAO,QAAQ,CAAA,CAAE;QAEtB,MAAM,4BAAwB,8OAAA,EAC5B,CAAC,QACC,qQAAA,CAAgB,IAAA,CAAK,cAAc;gBACjC,IAAI,IAAA,CAAK,OAAA;gBACT;YAAA,CACD,GACH;YACE,MAAM;QAAA;QAKV,IAAA,CAAK,KAAA,CAAM,SAAA,CAAU,MAAM;YACzB,sBAAsB,IAAA,CAAK,KAAA,CAAM,KAAK;QACxC,CAAC;QAGD,qQAAA,CAAgB,EAAA,CAAG,sBAAsB,CAAC,MAAM;YAC9C,IAAI,EAAE,OAAA,CAAQ,EAAA,KAAO,IAAA,CAAK,OAAA,EAAS;gBACjC,qQAAA,CAAgB,IAAA,CAAK,YAAY;oBAC/B,IAAI,IAAA,CAAK,OAAA;oBACT,OAAO,IAAA,CAAK,KAAA,CAAM,KAAA;oBAClB,SAAS,IAAA,CAAK,OAAA;gBAAA,CACf;YACH;QACF,CAAC;QAED,qQAAA,CAAgB,EAAA,CAAG,sBAAsB,CAAC,MAAM;YAC9C,IAAI,EAAE,OAAA,CAAQ,EAAA,KAAO,IAAA,CAAK,OAAA,EAAS;gBACjC,IAAA,CAAK,KAAA,CAAA;YACP;QACF,CAAC;QAED,qQAAA,CAAgB,EAAA,CAAG,6BAA6B,CAAC,MAAM;YACrD,IAAI,EAAE,OAAA,CAAQ,EAAA,KAAO,IAAA,CAAK,OAAA,EAAS;gBACjC,IAAA,CAAK,2BAAA,GAA8B;gBACnC,IAAA,CAAK,YAAA,CAAA;gBACL,IAAA,CAAK,2BAAA,GAA8B;YACrC;QACF,CAAC;IACH;AAi0CF;AAEA,SAAS,eAA0B,QAAA,EAGjC;IACA,IAAI,UAAU;QACZ,QAAI,2QAAA,EAA4B,QAAQ,GAAG;YACzC,MAAM,YAAY,eAAe,SAAS,IAAI,EAAE,SAAA;YAChD,MAAM,cAAc,SAAS,MAAA;YAC7B,OAAO;gBAAE;gBAAW;YAAA;QACtB;QAEA,OAAO;YAAE,WAAW;QAAA;IACtB;IAEA,OAAO;QAAE,WAAW,KAAA;IAAA;AACtB;AAEA,SAAS,eAAe,KAAA,EAAwB;IAC9C,OAAQ,OAAA;QACN,KAAK;YACH,OAAO;QACT,KAAK;YACH,OAAO;QACT,KAAK;YACH,OAAO;QACT,KAAK;YACH,OAAO;QACT,KAAK;YACH,OAAO;QACT,KAAK;QACL;YACE,OAAO;IAAA;AAEb","debugId":null}},
    {"offset": {"line": 1766, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.bun/@tanstack+form-core@1.24.4/node_modules/@tanstack/form-core/dist/esm/FieldApi.js","sources":["file:///C:/Proiect/groupware2/groupware/node_modules/.bun/%40tanstack%2Bform-core%401.24.4/node_modules/%40tanstack/form-core/src/FieldApi.ts"],"sourcesContent":["import { Derived, batch } from '@tanstack/store'\nimport {\n  isStandardSchemaValidator,\n  standardSchemaValidators,\n} from './standardSchemaValidator'\nimport { defaultFieldMeta } from './metaHelper'\nimport {\n  determineFieldLevelErrorSourceAndValue,\n  getAsyncValidatorArray,\n  getBy,\n  getSyncValidatorArray,\n  mergeOpts,\n} from './utils'\nimport { defaultValidationLogic } from './ValidationLogic'\nimport type { DeepKeys, DeepValue, UnwrapOneLevelOfArray } from './util-types'\nimport type {\n  StandardSchemaV1,\n  StandardSchemaV1Issue,\n  TStandardSchemaValidatorValue,\n} from './standardSchemaValidator'\nimport type {\n  FieldInfo,\n  FormApi,\n  FormAsyncValidateOrFn,\n  FormValidateAsyncFn,\n  FormValidateFn,\n  FormValidateOrFn,\n} from './FormApi'\nimport type {\n  ListenerCause,\n  UpdateMetaOptions,\n  ValidationCause,\n  ValidationError,\n  ValidationErrorMap,\n  ValidationErrorMapSource,\n} from './types'\nimport type { AsyncValidator, SyncValidator, Updater } from './utils'\n\n/**\n * @private\n */\n// TODO: Add the `Unwrap` type to the errors\ntype FieldErrorMapFromValidator<\n  TFormData,\n  TName extends DeepKeys<TFormData>,\n  TData extends DeepValue<TFormData, TName>,\n  TOnMount extends undefined | FieldValidateOrFn<TFormData, TName, TData>,\n  TOnChange extends undefined | FieldValidateOrFn<TFormData, TName, TData>,\n  TOnChangeAsync extends\n    | undefined\n    | FieldAsyncValidateOrFn<TFormData, TName, TData>,\n  TOnBlur extends undefined | FieldValidateOrFn<TFormData, TName, TData>,\n  TOnBlurAsync extends\n    | undefined\n    | FieldAsyncValidateOrFn<TFormData, TName, TData>,\n  TOnSubmit extends undefined | FieldValidateOrFn<TFormData, TName, TData>,\n  TOnSubmitAsync extends\n    | undefined\n    | FieldAsyncValidateOrFn<TFormData, TName, TData>,\n> = Partial<\n  Record<\n    DeepKeys<TFormData>,\n    ValidationErrorMap<\n      TOnMount,\n      TOnChange,\n      TOnChangeAsync,\n      TOnBlur,\n      TOnBlurAsync,\n      TOnSubmit,\n      TOnSubmitAsync\n    >\n  >\n>\n\n/**\n * @private\n */\nexport type FieldValidateFn<\n  TParentData,\n  TName extends DeepKeys<TParentData>,\n  TData extends DeepValue<TParentData, TName> = DeepValue<TParentData, TName>,\n> = (props: {\n  value: TData\n  fieldApi: FieldApi<\n    TParentData,\n    TName,\n    TData,\n    // This is technically an edge-type; which we try to keep non-`any`, but in this case\n    // It's referring to an inaccessible type from the field validate function inner types, so it's not a big deal\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any\n  >\n}) => unknown\n\n/**\n * @private\n */\nexport type FieldValidateOrFn<\n  TParentData,\n  TName extends DeepKeys<TParentData>,\n  TData extends DeepValue<TParentData, TName> = DeepValue<TParentData, TName>,\n> =\n  | FieldValidateFn<TParentData, TName, TData>\n  | StandardSchemaV1<TData, unknown>\n\ntype StandardBrandedSchemaV1<T> = T & { __standardSchemaV1: true }\n\ntype UnwrapFormValidateOrFnForInner<\n  TValidateOrFn extends undefined | FormValidateOrFn<any>,\n> = [TValidateOrFn] extends [FormValidateFn<any>]\n  ? ReturnType<TValidateOrFn>\n  : [TValidateOrFn] extends [StandardSchemaV1<infer TOut, any>]\n    ? StandardBrandedSchemaV1<TOut>\n    : undefined\n\nexport type UnwrapFieldValidateOrFn<\n  TName extends string,\n  TValidateOrFn extends undefined | FieldValidateOrFn<any, any, any>,\n  TFormValidateOrFn extends undefined | FormValidateOrFn<any>,\n> =\n  | ([TFormValidateOrFn] extends [StandardSchemaV1<any, infer TStandardOut>]\n      ? TName extends keyof TStandardOut\n        ? StandardSchemaV1Issue[]\n        : undefined\n      : undefined)\n  | (UnwrapFormValidateOrFnForInner<TFormValidateOrFn> extends infer TFormValidateVal\n      ? TFormValidateVal extends { __standardSchemaV1: true }\n        ? [DeepValue<TFormValidateVal, TName>] extends [never]\n          ? undefined\n          : StandardSchemaV1Issue[]\n        : TFormValidateVal extends { fields: any }\n          ? TName extends keyof TFormValidateVal['fields']\n            ? TFormValidateVal['fields'][TName]\n            : undefined\n          : undefined\n      : never)\n  | ([TValidateOrFn] extends [FieldValidateFn<any, any, any>]\n      ? ReturnType<TValidateOrFn>\n      : [TValidateOrFn] extends [StandardSchemaV1<any, any>]\n        ? // TODO: Check if `disableErrorFlat` is enabled, if so, return StandardSchemaV1Issue[][]\n          StandardSchemaV1Issue[]\n        : undefined)\n\n/**\n * @private\n */\nexport type FieldValidateAsyncFn<\n  TParentData,\n  TName extends DeepKeys<TParentData>,\n  TData extends DeepValue<TParentData, TName> = DeepValue<TParentData, TName>,\n> = (options: {\n  value: TData\n  fieldApi: FieldApi<\n    TParentData,\n    TName,\n    TData,\n    // This is technically an edge-type; which we try to keep non-`any`, but in this case\n    // It's referring to an inaccessible type from the field validate function inner types, so it's not a big deal\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any\n  >\n  signal: AbortSignal\n}) => unknown | Promise<unknown>\n\n/**\n * @private\n */\nexport type FieldAsyncValidateOrFn<\n  TParentData,\n  TName extends DeepKeys<TParentData>,\n  TData extends DeepValue<TParentData, TName> = DeepValue<TParentData, TName>,\n> =\n  | FieldValidateAsyncFn<TParentData, TName, TData>\n  | StandardSchemaV1<TData, unknown>\n\ntype UnwrapFormAsyncValidateOrFnForInner<\n  TValidateOrFn extends undefined | FormAsyncValidateOrFn<any>,\n> = [TValidateOrFn] extends [FormValidateAsyncFn<any>]\n  ? Awaited<ReturnType<TValidateOrFn>>\n  : [TValidateOrFn] extends [StandardSchemaV1<infer TOut, any>]\n    ? StandardBrandedSchemaV1<TOut>\n    : undefined\n\nexport type UnwrapFieldAsyncValidateOrFn<\n  TName extends string,\n  TValidateOrFn extends undefined | FieldAsyncValidateOrFn<any, any, any>,\n  TFormValidateOrFn extends undefined | FormAsyncValidateOrFn<any>,\n> =\n  | ([TFormValidateOrFn] extends [StandardSchemaV1<any, infer TStandardOut>]\n      ? TName extends keyof TStandardOut\n        ? StandardSchemaV1Issue[]\n        : undefined\n      : undefined)\n  | (UnwrapFormAsyncValidateOrFnForInner<TFormValidateOrFn> extends infer TFormValidateVal\n      ? TFormValidateVal extends { __standardSchemaV1: true }\n        ? [DeepValue<TFormValidateVal, TName>] extends [never]\n          ? undefined\n          : StandardSchemaV1Issue[]\n        : TFormValidateVal extends { fields: any }\n          ? TName extends keyof TFormValidateVal['fields']\n            ? TFormValidateVal['fields'][TName]\n            : undefined\n          : undefined\n      : never)\n  | ([TValidateOrFn] extends [FieldValidateAsyncFn<any, any, any>]\n      ? Awaited<ReturnType<TValidateOrFn>>\n      : [TValidateOrFn] extends [StandardSchemaV1<any, any>]\n        ? // TODO: Check if `disableErrorFlat` is enabled, if so, return StandardSchemaV1Issue[][]\n          StandardSchemaV1Issue[]\n        : undefined)\n\n/**\n * @private\n */\nexport type FieldListenerFn<\n  TParentData,\n  TName extends DeepKeys<TParentData>,\n  TData extends DeepValue<TParentData, TName> = DeepValue<TParentData, TName>,\n> = (props: {\n  value: TData\n  fieldApi: FieldApi<\n    TParentData,\n    TName,\n    TData,\n    // This is technically an edge-type; which we try to keep non-`any`, but in this case\n    // It's referring to an inaccessible type from the field listener function inner types, so it's not a big deal\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any\n  >\n}) => void\n\nexport interface FieldValidators<\n  TParentData,\n  TName extends DeepKeys<TParentData>,\n  TData extends DeepValue<TParentData, TName>,\n  TOnMount extends undefined | FieldValidateOrFn<TParentData, TName, TData>,\n  TOnChange extends undefined | FieldValidateOrFn<TParentData, TName, TData>,\n  TOnChangeAsync extends\n    | undefined\n    | FieldAsyncValidateOrFn<TParentData, TName, TData>,\n  TOnBlur extends undefined | FieldValidateOrFn<TParentData, TName, TData>,\n  TOnBlurAsync extends\n    | undefined\n    | FieldAsyncValidateOrFn<TParentData, TName, TData>,\n  TOnSubmit extends undefined | FieldValidateOrFn<TParentData, TName, TData>,\n  TOnSubmitAsync extends\n    | undefined\n    | FieldAsyncValidateOrFn<TParentData, TName, TData>,\n  TOnDynamic extends undefined | FieldValidateOrFn<TParentData, TName, TData>,\n  TOnDynamicAsync extends\n    | undefined\n    | FieldAsyncValidateOrFn<TParentData, TName, TData>,\n> {\n  /**\n   * An optional function, that runs on the mount event of input.\n   */\n  onMount?: TOnMount\n  /**\n   * An optional function, that runs on the change event of input.\n   *\n   * @example z.string().min(1)\n   */\n  onChange?: TOnChange\n  /**\n   * An optional property similar to `onChange` but async validation\n   *\n   * @example z.string().refine(async (val) => val.length > 3, { message: 'Testing 123' })\n   */\n  onChangeAsync?: TOnChangeAsync\n  /**\n   * An optional number to represent how long the `onChangeAsync` should wait before running\n   *\n   * If set to a number larger than 0, will debounce the async validation event by this length of time in milliseconds\n   */\n  onChangeAsyncDebounceMs?: number\n  /**\n   * An optional list of field names that should trigger this field's `onChange` and `onChangeAsync` events when its value changes\n   */\n  onChangeListenTo?: DeepKeys<TParentData>[]\n  /**\n   * An optional function, that runs on the blur event of input.\n   *\n   * @example z.string().min(1)\n   */\n  onBlur?: TOnBlur\n  /**\n   * An optional property similar to `onBlur` but async validation.\n   *\n   * @example z.string().refine(async (val) => val.length > 3, { message: 'Testing 123' })\n   */\n  onBlurAsync?: TOnBlurAsync\n\n  /**\n   * An optional number to represent how long the `onBlurAsync` should wait before running\n   *\n   * If set to a number larger than 0, will debounce the async validation event by this length of time in milliseconds\n   */\n  onBlurAsyncDebounceMs?: number\n  /**\n   * An optional list of field names that should trigger this field's `onBlur` and `onBlurAsync` events when its value changes\n   */\n  onBlurListenTo?: DeepKeys<TParentData>[]\n  /**\n   * An optional function, that runs on the submit event of form.\n   *\n   * @example z.string().min(1)\n   */\n  onSubmit?: TOnSubmit\n  /**\n   * An optional property similar to `onSubmit` but async validation.\n   *\n   * @example z.string().refine(async (val) => val.length > 3, { message: 'Testing 123' })\n   */\n  onSubmitAsync?: TOnSubmitAsync\n  onDynamic?: TOnDynamic\n  onDynamicAsync?: TOnDynamicAsync\n  onDynamicAsyncDebounceMs?: number\n}\n\nexport interface FieldListeners<\n  TParentData,\n  TName extends DeepKeys<TParentData>,\n  TData extends DeepValue<TParentData, TName> = DeepValue<TParentData, TName>,\n> {\n  onChange?: FieldListenerFn<TParentData, TName, TData>\n  onChangeDebounceMs?: number\n  onBlur?: FieldListenerFn<TParentData, TName, TData>\n  onBlurDebounceMs?: number\n  onMount?: FieldListenerFn<TParentData, TName, TData>\n  onSubmit?: FieldListenerFn<TParentData, TName, TData>\n}\n\n/**\n * An object type representing the options for a field in a form.\n */\nexport interface FieldOptions<\n  TParentData,\n  TName extends DeepKeys<TParentData>,\n  TData extends DeepValue<TParentData, TName>,\n  TOnMount extends undefined | FieldValidateOrFn<TParentData, TName, TData>,\n  TOnChange extends undefined | FieldValidateOrFn<TParentData, TName, TData>,\n  TOnChangeAsync extends\n    | undefined\n    | FieldAsyncValidateOrFn<TParentData, TName, TData>,\n  TOnBlur extends undefined | FieldValidateOrFn<TParentData, TName, TData>,\n  TOnBlurAsync extends\n    | undefined\n    | FieldAsyncValidateOrFn<TParentData, TName, TData>,\n  TOnSubmit extends undefined | FieldValidateOrFn<TParentData, TName, TData>,\n  TOnSubmitAsync extends\n    | undefined\n    | FieldAsyncValidateOrFn<TParentData, TName, TData>,\n  TOnDynamic extends undefined | FieldValidateOrFn<TParentData, TName, TData>,\n  TOnDynamicAsync extends\n    | undefined\n    | FieldAsyncValidateOrFn<TParentData, TName, TData>,\n> {\n  /**\n   * The field name. The type will be `DeepKeys<TParentData>` to ensure your name is a deep key of the parent dataset.\n   */\n  name: TName\n  /**\n   * An optional default value for the field.\n   */\n  defaultValue?: NoInfer<TData>\n  /**\n   * The default time to debounce async validation if there is not a more specific debounce time passed.\n   */\n  asyncDebounceMs?: number\n  /**\n   * If `true`, always run async validation, even if there are errors emitted during synchronous validation.\n   */\n  asyncAlways?: boolean\n  /**\n   * A list of validators to pass to the field\n   */\n  validators?: FieldValidators<\n    TParentData,\n    TName,\n    TData,\n    TOnMount,\n    TOnChange,\n    TOnChangeAsync,\n    TOnBlur,\n    TOnBlurAsync,\n    TOnSubmit,\n    TOnSubmitAsync,\n    TOnDynamic,\n    TOnDynamicAsync\n  >\n  /**\n   * An optional object with default metadata for the field.\n   */\n  defaultMeta?: Partial<\n    FieldMeta<\n      TParentData,\n      TName,\n      TData,\n      TOnMount,\n      TOnChange,\n      TOnChangeAsync,\n      TOnBlur,\n      TOnBlurAsync,\n      TOnSubmit,\n      TOnSubmitAsync,\n      TOnDynamic,\n      TOnDynamicAsync,\n      any,\n      any,\n      any,\n      any,\n      any,\n      any,\n      any,\n      any,\n      any\n    >\n  >\n  /**\n   * A list of listeners which attach to the corresponding events\n   */\n  listeners?: FieldListeners<TParentData, TName, TData>\n  /**\n   * Disable the `flat(1)` operation on `field.errors`. This is useful if you want to keep the error structure as is. Not suggested for most use-cases.\n   */\n  disableErrorFlat?: boolean\n}\n\n/**\n * An object type representing the required options for the FieldApi class.\n */\nexport interface FieldApiOptions<\n  in out TParentData,\n  in out TName extends DeepKeys<TParentData>,\n  in out TData extends DeepValue<TParentData, TName>,\n  in out TOnMount extends\n    | undefined\n    | FieldValidateOrFn<TParentData, TName, TData>,\n  in out TOnChange extends\n    | undefined\n    | FieldValidateOrFn<TParentData, TName, TData>,\n  in out TOnChangeAsync extends\n    | undefined\n    | FieldAsyncValidateOrFn<TParentData, TName, TData>,\n  in out TOnBlur extends\n    | undefined\n    | FieldValidateOrFn<TParentData, TName, TData>,\n  in out TOnBlurAsync extends\n    | undefined\n    | FieldAsyncValidateOrFn<TParentData, TName, TData>,\n  in out TOnSubmit extends\n    | undefined\n    | FieldValidateOrFn<TParentData, TName, TData>,\n  in out TOnSubmitAsync extends\n    | undefined\n    | FieldAsyncValidateOrFn<TParentData, TName, TData>,\n  in out TOnDynamic extends\n    | undefined\n    | FieldValidateOrFn<TParentData, TName, TData>,\n  in out TOnDynamicAsync extends\n    | undefined\n    | FieldAsyncValidateOrFn<TParentData, TName, TData>,\n  in out TFormOnMount extends undefined | FormValidateOrFn<TParentData>,\n  in out TFormOnChange extends undefined | FormValidateOrFn<TParentData>,\n  in out TFormOnChangeAsync extends\n    | undefined\n    | FormAsyncValidateOrFn<TParentData>,\n  in out TFormOnBlur extends undefined | FormValidateOrFn<TParentData>,\n  in out TFormOnBlurAsync extends\n    | undefined\n    | FormAsyncValidateOrFn<TParentData>,\n  in out TFormOnSubmit extends undefined | FormValidateOrFn<TParentData>,\n  in out TFormOnSubmitAsync extends\n    | undefined\n    | FormAsyncValidateOrFn<TParentData>,\n  in out TFormOnDynamic extends undefined | FormValidateOrFn<TParentData>,\n  in out TFormOnDynamicAsync extends\n    | undefined\n    | FormAsyncValidateOrFn<TParentData>,\n  in out TFormOnServer extends undefined | FormAsyncValidateOrFn<TParentData>,\n  in out TParentSubmitMeta,\n> extends FieldOptions<\n    TParentData,\n    TName,\n    TData,\n    TOnMount,\n    TOnChange,\n    TOnChangeAsync,\n    TOnBlur,\n    TOnBlurAsync,\n    TOnSubmit,\n    TOnSubmitAsync,\n    TOnDynamic,\n    TOnDynamicAsync\n  > {\n  form: FormApi<\n    TParentData,\n    TFormOnMount,\n    TFormOnChange,\n    TFormOnChangeAsync,\n    TFormOnBlur,\n    TFormOnBlurAsync,\n    TFormOnSubmit,\n    TFormOnSubmitAsync,\n    TFormOnDynamic,\n    TFormOnDynamicAsync,\n    TFormOnServer,\n    TParentSubmitMeta\n  >\n}\n\nexport type FieldMetaBase<\n  TParentData,\n  TName extends DeepKeys<TParentData>,\n  TData extends DeepValue<TParentData, TName>,\n  TOnMount extends undefined | FieldValidateOrFn<TParentData, TName, TData>,\n  TOnChange extends undefined | FieldValidateOrFn<TParentData, TName, TData>,\n  TOnChangeAsync extends\n    | undefined\n    | FieldAsyncValidateOrFn<TParentData, TName, TData>,\n  TOnBlur extends undefined | FieldValidateOrFn<TParentData, TName, TData>,\n  TOnBlurAsync extends\n    | undefined\n    | FieldAsyncValidateOrFn<TParentData, TName, TData>,\n  TOnSubmit extends undefined | FieldValidateOrFn<TParentData, TName, TData>,\n  TOnSubmitAsync extends\n    | undefined\n    | FieldAsyncValidateOrFn<TParentData, TName, TData>,\n  TOnDynamic extends undefined | FieldValidateOrFn<TParentData, TName, TData>,\n  TOnDynamicAsync extends\n    | undefined\n    | FieldAsyncValidateOrFn<TParentData, TName, TData>,\n  TFormOnMount extends undefined | FormValidateOrFn<TParentData>,\n  TFormOnChange extends undefined | FormValidateOrFn<TParentData>,\n  TFormOnChangeAsync extends undefined | FormAsyncValidateOrFn<TParentData>,\n  TFormOnBlur extends undefined | FormValidateOrFn<TParentData>,\n  TFormOnBlurAsync extends undefined | FormAsyncValidateOrFn<TParentData>,\n  TFormOnSubmit extends undefined | FormValidateOrFn<TParentData>,\n  TFormOnSubmitAsync extends undefined | FormAsyncValidateOrFn<TParentData>,\n  TFormOnDynamic extends undefined | FormValidateOrFn<TParentData>,\n  TFormOnDynamicAsync extends undefined | FormAsyncValidateOrFn<TParentData>,\n> = {\n  /**\n   * A flag indicating whether the field has been touched.\n   */\n  isTouched: boolean\n  /**\n   * A flag indicating whether the field has been blurred.\n   */\n  isBlurred: boolean\n  /**\n   * A flag that is `true` if the field's value has been modified by the user. Opposite of `isPristine`.\n   */\n  isDirty: boolean\n  /**\n   * A map of errors related to the field value.\n   */\n  errorMap: ValidationErrorMap<\n    UnwrapFieldValidateOrFn<TName, TOnMount, TFormOnMount>,\n    UnwrapFieldValidateOrFn<TName, TOnChange, TFormOnChange>,\n    UnwrapFieldAsyncValidateOrFn<TName, TOnChangeAsync, TFormOnChangeAsync>,\n    UnwrapFieldValidateOrFn<TName, TOnBlur, TFormOnBlur>,\n    UnwrapFieldAsyncValidateOrFn<TName, TOnBlurAsync, TFormOnBlurAsync>,\n    UnwrapFieldValidateOrFn<TName, TOnSubmit, TFormOnSubmit>,\n    UnwrapFieldAsyncValidateOrFn<TName, TOnSubmitAsync, TFormOnSubmitAsync>,\n    UnwrapFieldValidateOrFn<TName, TOnDynamic, TFormOnDynamic>,\n    UnwrapFieldAsyncValidateOrFn<TName, TOnDynamicAsync, TFormOnDynamicAsync>\n  >\n\n  /**\n   * @private allows tracking the source of the errors in the error map\n   */\n  errorSourceMap: ValidationErrorMapSource\n  /**\n   * A flag indicating whether the field is currently being validated.\n   */\n  isValidating: boolean\n}\n\nexport type AnyFieldMetaBase = FieldMetaBase<\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any\n>\n\nexport type FieldMetaDerived<\n  TParentData,\n  TName extends DeepKeys<TParentData>,\n  TData extends DeepValue<TParentData, TName>,\n  TOnMount extends undefined | FieldValidateOrFn<TParentData, TName, TData>,\n  TOnChange extends undefined | FieldValidateOrFn<TParentData, TName, TData>,\n  TOnChangeAsync extends\n    | undefined\n    | FieldAsyncValidateOrFn<TParentData, TName, TData>,\n  TOnBlur extends undefined | FieldValidateOrFn<TParentData, TName, TData>,\n  TOnBlurAsync extends\n    | undefined\n    | FieldAsyncValidateOrFn<TParentData, TName, TData>,\n  TOnSubmit extends undefined | FieldValidateOrFn<TParentData, TName, TData>,\n  TOnSubmitAsync extends\n    | undefined\n    | FieldAsyncValidateOrFn<TParentData, TName, TData>,\n  TOnDynamic extends undefined | FieldValidateOrFn<TParentData, TName, TData>,\n  TOnDynamicAsync extends\n    | undefined\n    | FieldAsyncValidateOrFn<TParentData, TName, TData>,\n  TFormOnMount extends undefined | FormValidateOrFn<TParentData>,\n  TFormOnChange extends undefined | FormValidateOrFn<TParentData>,\n  TFormOnChangeAsync extends undefined | FormAsyncValidateOrFn<TParentData>,\n  TFormOnBlur extends undefined | FormValidateOrFn<TParentData>,\n  TFormOnBlurAsync extends undefined | FormAsyncValidateOrFn<TParentData>,\n  TFormOnSubmit extends undefined | FormValidateOrFn<TParentData>,\n  TFormOnSubmitAsync extends undefined | FormAsyncValidateOrFn<TParentData>,\n  TFormOnDynamic extends undefined | FormValidateOrFn<TParentData>,\n  TFormOnDynamicAsync extends undefined | FormAsyncValidateOrFn<TParentData>,\n> = {\n  /**\n   * An array of errors related to the field value.\n   */\n  errors: Array<\n    | UnwrapOneLevelOfArray<\n        UnwrapFieldValidateOrFn<TName, TOnMount, TFormOnMount>\n      >\n    | UnwrapOneLevelOfArray<\n        UnwrapFieldValidateOrFn<TName, TOnChange, TFormOnChange>\n      >\n    | UnwrapOneLevelOfArray<\n        UnwrapFieldAsyncValidateOrFn<TName, TOnChangeAsync, TFormOnChangeAsync>\n      >\n    | UnwrapOneLevelOfArray<\n        UnwrapFieldValidateOrFn<TName, TOnBlur, TFormOnBlur>\n      >\n    | UnwrapOneLevelOfArray<\n        UnwrapFieldAsyncValidateOrFn<TName, TOnBlurAsync, TFormOnBlurAsync>\n      >\n    | UnwrapOneLevelOfArray<\n        UnwrapFieldValidateOrFn<TName, TOnSubmit, TFormOnSubmit>\n      >\n    | UnwrapOneLevelOfArray<\n        UnwrapFieldAsyncValidateOrFn<TName, TOnSubmitAsync, TFormOnSubmitAsync>\n      >\n    | UnwrapOneLevelOfArray<\n        UnwrapFieldValidateOrFn<TName, TOnDynamic, TFormOnDynamic>\n      >\n    | UnwrapOneLevelOfArray<\n        UnwrapFieldAsyncValidateOrFn<\n          TName,\n          TOnDynamicAsync,\n          TFormOnDynamicAsync\n        >\n      >\n  >\n  /**\n   * A flag that is `true` if the field's value has not been modified by the user. Opposite of `isDirty`.\n   */\n  isPristine: boolean\n  /**\n   * A boolean indicating if the field is valid. Evaluates `true` if there are no field errors.\n   */\n  isValid: boolean\n  /**\n   * A flag indicating whether the field's current value is the default value\n   */\n  isDefaultValue: boolean\n}\n\nexport type AnyFieldMetaDerived = FieldMetaDerived<\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any\n>\n\n/**\n * An object type representing the metadata of a field in a form.\n */\nexport type FieldMeta<\n  TParentData,\n  TName extends DeepKeys<TParentData>,\n  TData extends DeepValue<TParentData, TName>,\n  TOnMount extends undefined | FieldValidateOrFn<TParentData, TName, TData>,\n  TOnChange extends undefined | FieldValidateOrFn<TParentData, TName, TData>,\n  TOnChangeAsync extends\n    | undefined\n    | FieldAsyncValidateOrFn<TParentData, TName, TData>,\n  TOnBlur extends undefined | FieldValidateOrFn<TParentData, TName, TData>,\n  TOnBlurAsync extends\n    | undefined\n    | FieldAsyncValidateOrFn<TParentData, TName, TData>,\n  TOnSubmit extends undefined | FieldValidateOrFn<TParentData, TName, TData>,\n  TOnSubmitAsync extends\n    | undefined\n    | FieldAsyncValidateOrFn<TParentData, TName, TData>,\n  TOnDynamic extends undefined | FieldValidateOrFn<TParentData, TName, TData>,\n  TOnDynamicAsync extends\n    | undefined\n    | FieldAsyncValidateOrFn<TParentData, TName, TData>,\n  TFormOnMount extends undefined | FormValidateOrFn<TParentData>,\n  TFormOnChange extends undefined | FormValidateOrFn<TParentData>,\n  TFormOnChangeAsync extends undefined | FormAsyncValidateOrFn<TParentData>,\n  TFormOnBlur extends undefined | FormValidateOrFn<TParentData>,\n  TFormOnBlurAsync extends undefined | FormAsyncValidateOrFn<TParentData>,\n  TFormOnSubmit extends undefined | FormValidateOrFn<TParentData>,\n  TFormOnSubmitAsync extends undefined | FormAsyncValidateOrFn<TParentData>,\n  TFormOnDynamic extends undefined | FormValidateOrFn<TParentData>,\n  TFormOnDynamicAsync extends undefined | FormAsyncValidateOrFn<TParentData>,\n> = FieldMetaBase<\n  TParentData,\n  TName,\n  TData,\n  TOnMount,\n  TOnChange,\n  TOnChangeAsync,\n  TOnBlur,\n  TOnBlurAsync,\n  TOnSubmit,\n  TOnSubmitAsync,\n  TOnDynamic,\n  TOnDynamicAsync,\n  TFormOnMount,\n  TFormOnChange,\n  TFormOnChangeAsync,\n  TFormOnBlur,\n  TFormOnBlurAsync,\n  TFormOnSubmit,\n  TFormOnSubmitAsync,\n  TFormOnDynamic,\n  TFormOnDynamicAsync\n> &\n  FieldMetaDerived<\n    TParentData,\n    TName,\n    TData,\n    TOnMount,\n    TOnChange,\n    TOnChangeAsync,\n    TOnBlur,\n    TOnBlurAsync,\n    TOnSubmit,\n    TOnSubmitAsync,\n    TOnDynamic,\n    TOnDynamicAsync,\n    TFormOnMount,\n    TFormOnChange,\n    TFormOnChangeAsync,\n    TFormOnBlur,\n    TFormOnBlurAsync,\n    TFormOnSubmit,\n    TFormOnSubmitAsync,\n    TFormOnDynamic,\n    TFormOnDynamicAsync\n  >\n\nexport type AnyFieldMeta = FieldMeta<\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any\n>\n\n/**\n * An object type representing the state of a field.\n */\nexport type FieldState<\n  TParentData,\n  TName extends DeepKeys<TParentData>,\n  TData extends DeepValue<TParentData, TName>,\n  TOnMount extends undefined | FieldValidateOrFn<TParentData, TName, TData>,\n  TOnChange extends undefined | FieldValidateOrFn<TParentData, TName, TData>,\n  TOnChangeAsync extends\n    | undefined\n    | FieldAsyncValidateOrFn<TParentData, TName, TData>,\n  TOnBlur extends undefined | FieldValidateOrFn<TParentData, TName, TData>,\n  TOnBlurAsync extends\n    | undefined\n    | FieldAsyncValidateOrFn<TParentData, TName, TData>,\n  TOnSubmit extends undefined | FieldValidateOrFn<TParentData, TName, TData>,\n  TOnSubmitAsync extends\n    | undefined\n    | FieldAsyncValidateOrFn<TParentData, TName, TData>,\n  TOnDynamic extends undefined | FieldValidateOrFn<TParentData, TName, TData>,\n  TOnDynamicAsync extends\n    | undefined\n    | FieldAsyncValidateOrFn<TParentData, TName, TData>,\n  TFormOnMount extends undefined | FormValidateOrFn<TParentData>,\n  TFormOnChange extends undefined | FormValidateOrFn<TParentData>,\n  TFormOnChangeAsync extends undefined | FormAsyncValidateOrFn<TParentData>,\n  TFormOnBlur extends undefined | FormValidateOrFn<TParentData>,\n  TFormOnBlurAsync extends undefined | FormAsyncValidateOrFn<TParentData>,\n  TFormOnSubmit extends undefined | FormValidateOrFn<TParentData>,\n  TFormOnSubmitAsync extends undefined | FormAsyncValidateOrFn<TParentData>,\n  TFormOnDynamic extends undefined | FormValidateOrFn<TParentData>,\n  TFormOnDynamicAsync extends undefined | FormAsyncValidateOrFn<TParentData>,\n> = {\n  /**\n   * The current value of the field.\n   */\n  value: TData\n  /**\n   * The current metadata of the field.\n   */\n  meta: FieldMeta<\n    TParentData,\n    TName,\n    TData,\n    TOnMount,\n    TOnChange,\n    TOnChangeAsync,\n    TOnBlur,\n    TOnBlurAsync,\n    TOnSubmit,\n    TOnSubmitAsync,\n    TOnDynamic,\n    TOnDynamicAsync,\n    TFormOnMount,\n    TFormOnChange,\n    TFormOnChangeAsync,\n    TFormOnBlur,\n    TFormOnBlurAsync,\n    TFormOnSubmit,\n    TFormOnSubmitAsync,\n    TFormOnDynamic,\n    TFormOnDynamicAsync\n  >\n}\n\n/**\n * @public\n *\n * A type representing the Field API with all generics set to `any` for convenience.\n */\nexport type AnyFieldApi = FieldApi<\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any\n>\n\n/**\n * A class representing the API for managing a form field.\n *\n * Normally, you will not need to create a new `FieldApi` instance directly.\n * Instead, you will use a framework hook/function like `useField` or `createField`\n * to create a new instance for you that uses your framework's reactivity model.\n * However, if you need to create a new instance manually, you can do so by calling\n * the `new FieldApi` constructor.\n */\nexport class FieldApi<\n  in out TParentData,\n  in out TName extends DeepKeys<TParentData>,\n  in out TData extends DeepValue<TParentData, TName>,\n  in out TOnMount extends\n    | undefined\n    | FieldValidateOrFn<TParentData, TName, TData>,\n  in out TOnChange extends\n    | undefined\n    | FieldValidateOrFn<TParentData, TName, TData>,\n  in out TOnChangeAsync extends\n    | undefined\n    | FieldAsyncValidateOrFn<TParentData, TName, TData>,\n  in out TOnBlur extends\n    | undefined\n    | FieldValidateOrFn<TParentData, TName, TData>,\n  in out TOnBlurAsync extends\n    | undefined\n    | FieldAsyncValidateOrFn<TParentData, TName, TData>,\n  in out TOnSubmit extends\n    | undefined\n    | FieldValidateOrFn<TParentData, TName, TData>,\n  in out TOnSubmitAsync extends\n    | undefined\n    | FieldAsyncValidateOrFn<TParentData, TName, TData>,\n  in out TOnDynamic extends\n    | undefined\n    | FieldValidateOrFn<TParentData, TName, TData>,\n  in out TOnDynamicAsync extends\n    | undefined\n    | FieldAsyncValidateOrFn<TParentData, TName, TData>,\n  in out TFormOnMount extends undefined | FormValidateOrFn<TParentData>,\n  in out TFormOnChange extends undefined | FormValidateOrFn<TParentData>,\n  in out TFormOnChangeAsync extends\n    | undefined\n    | FormAsyncValidateOrFn<TParentData>,\n  in out TFormOnBlur extends undefined | FormValidateOrFn<TParentData>,\n  in out TFormOnBlurAsync extends\n    | undefined\n    | FormAsyncValidateOrFn<TParentData>,\n  in out TFormOnSubmit extends undefined | FormValidateOrFn<TParentData>,\n  in out TFormOnSubmitAsync extends\n    | undefined\n    | FormAsyncValidateOrFn<TParentData>,\n  in out TFormOnDynamic extends undefined | FormValidateOrFn<TParentData>,\n  in out TFormOnDynamicAsync extends\n    | undefined\n    | FormAsyncValidateOrFn<TParentData>,\n  in out TFormOnServer extends undefined | FormAsyncValidateOrFn<TParentData>,\n  in out TParentSubmitMeta,\n> {\n  /**\n   * A reference to the form API instance.\n   */\n  form: FieldApiOptions<\n    TParentData,\n    TName,\n    TData,\n    TOnMount,\n    TOnChange,\n    TOnChangeAsync,\n    TOnBlur,\n    TOnBlurAsync,\n    TOnSubmit,\n    TOnSubmitAsync,\n    TOnDynamic,\n    TOnDynamicAsync,\n    TFormOnMount,\n    TFormOnChange,\n    TFormOnChangeAsync,\n    TFormOnBlur,\n    TFormOnBlurAsync,\n    TFormOnSubmit,\n    TFormOnSubmitAsync,\n    TFormOnDynamic,\n    TFormOnDynamicAsync,\n    TFormOnServer,\n    TParentSubmitMeta\n  >['form']\n  /**\n   * The field name.\n   */\n  name!: DeepKeys<TParentData>\n  /**\n   * The field options.\n   */\n  options: FieldApiOptions<\n    TParentData,\n    TName,\n    TData,\n    TOnMount,\n    TOnChange,\n    TOnChangeAsync,\n    TOnBlur,\n    TOnBlurAsync,\n    TOnSubmit,\n    TOnSubmitAsync,\n    TOnDynamic,\n    TOnDynamicAsync,\n    TFormOnMount,\n    TFormOnChange,\n    TFormOnChangeAsync,\n    TFormOnBlur,\n    TFormOnBlurAsync,\n    TFormOnSubmit,\n    TFormOnSubmitAsync,\n    TFormOnDynamic,\n    TFormOnDynamicAsync,\n    TFormOnServer,\n    TParentSubmitMeta\n  > = {} as any\n  /**\n   * The field state store.\n   */\n  store!: Derived<\n    FieldState<\n      TParentData,\n      TName,\n      TData,\n      TOnMount,\n      TOnChange,\n      TOnChangeAsync,\n      TOnBlur,\n      TOnBlurAsync,\n      TOnSubmit,\n      TOnSubmitAsync,\n      TOnDynamic,\n      TOnDynamicAsync,\n      TFormOnMount,\n      TFormOnChange,\n      TFormOnChangeAsync,\n      TFormOnBlur,\n      TFormOnBlurAsync,\n      TFormOnSubmit,\n      TFormOnSubmitAsync,\n      TFormOnDynamic,\n      TFormOnDynamicAsync\n    >\n  >\n  /**\n   * The current field state.\n   */\n  get state() {\n    return this.store.state\n  }\n  timeoutIds: {\n    validations: Record<ValidationCause, ReturnType<typeof setTimeout> | null>\n    listeners: Record<ListenerCause, ReturnType<typeof setTimeout> | null>\n    formListeners: Record<ListenerCause, ReturnType<typeof setTimeout> | null>\n  }\n\n  /**\n   * Initializes a new `FieldApi` instance.\n   */\n  constructor(\n    opts: FieldApiOptions<\n      TParentData,\n      TName,\n      TData,\n      TOnMount,\n      TOnChange,\n      TOnChangeAsync,\n      TOnBlur,\n      TOnBlurAsync,\n      TOnSubmit,\n      TOnSubmitAsync,\n      TOnDynamic,\n      TOnDynamicAsync,\n      TFormOnMount,\n      TFormOnChange,\n      TFormOnChangeAsync,\n      TFormOnBlur,\n      TFormOnBlurAsync,\n      TFormOnSubmit,\n      TFormOnSubmitAsync,\n      TFormOnDynamic,\n      TFormOnDynamicAsync,\n      TFormOnServer,\n      TParentSubmitMeta\n    >,\n  ) {\n    this.form = opts.form as never\n    this.name = opts.name as never\n    this.timeoutIds = {\n      validations: {} as Record<ValidationCause, never>,\n      listeners: {} as Record<ListenerCause, never>,\n      formListeners: {} as Record<ListenerCause, never>,\n    }\n\n    this.store = new Derived({\n      deps: [this.form.store],\n      fn: () => {\n        const value = this.form.getFieldValue(this.name)\n        const meta = this.form.getFieldMeta(this.name) ?? {\n          ...defaultFieldMeta,\n          ...opts.defaultMeta,\n        }\n\n        return {\n          value,\n          meta,\n        } as FieldState<\n          TParentData,\n          TName,\n          TData,\n          TOnMount,\n          TOnChange,\n          TOnChangeAsync,\n          TOnBlur,\n          TOnBlurAsync,\n          TOnSubmit,\n          TOnSubmitAsync,\n          TOnDynamic,\n          TOnDynamicAsync,\n          TFormOnMount,\n          TFormOnChange,\n          TFormOnChangeAsync,\n          TFormOnBlur,\n          TFormOnBlurAsync,\n          TFormOnSubmit,\n          TFormOnSubmitAsync,\n          TFormOnDynamic,\n          TFormOnDynamicAsync\n        >\n      },\n    })\n\n    this.options = opts as never\n  }\n\n  /**\n   * @private\n   */\n  runValidator<\n    TValue extends TStandardSchemaValidatorValue<TData> & {\n      fieldApi: AnyFieldApi\n    },\n    TType extends 'validate' | 'validateAsync',\n  >(props: {\n    validate: TType extends 'validate'\n      ? FieldValidateOrFn<any, any, any>\n      : FieldAsyncValidateOrFn<any, any, any>\n    value: TValue\n    type: TType\n    // When `api` is 'field', the return type cannot be `FormValidationError`\n  }): unknown {\n    if (isStandardSchemaValidator(props.validate)) {\n      return standardSchemaValidators[props.type](\n        props.value,\n        props.validate,\n      ) as never\n    }\n\n    return (props.validate as FieldValidateFn<any, any>)(props.value) as never\n  }\n\n  /**\n   * Mounts the field instance to the form.\n   */\n  mount = () => {\n    const cleanup = this.store.mount()\n\n    if ((this.options.defaultValue as unknown) !== undefined) {\n      this.form.setFieldValue(this.name, this.options.defaultValue as never, {\n        dontUpdateMeta: true,\n      })\n    }\n\n    const info = this.getInfo()\n    info.instance = this as never\n\n    this.update(this.options as never)\n    const { onMount } = this.options.validators || {}\n\n    if (onMount) {\n      const error = this.runValidator({\n        validate: onMount,\n        value: {\n          value: this.state.value,\n          fieldApi: this,\n          validationSource: 'field',\n        },\n        type: 'validate',\n      })\n      if (error) {\n        this.setMeta(\n          (prev) =>\n            ({\n              ...prev,\n              // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n              errorMap: { ...prev?.errorMap, onMount: error },\n              errorSourceMap: {\n                // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n                ...prev?.errorSourceMap,\n                onMount: 'field',\n              },\n            }) as never,\n        )\n      }\n    }\n\n    this.options.listeners?.onMount?.({\n      value: this.state.value,\n      fieldApi: this,\n    })\n\n    return cleanup\n  }\n\n  /**\n   * Updates the field instance with new options.\n   */\n  update = (\n    opts: FieldApiOptions<\n      TParentData,\n      TName,\n      TData,\n      TOnMount,\n      TOnChange,\n      TOnChangeAsync,\n      TOnBlur,\n      TOnBlurAsync,\n      TOnSubmit,\n      TOnSubmitAsync,\n      TOnDynamic,\n      TOnDynamicAsync,\n      TFormOnMount,\n      TFormOnChange,\n      TFormOnChangeAsync,\n      TFormOnBlur,\n      TFormOnBlurAsync,\n      TFormOnSubmit,\n      TFormOnSubmitAsync,\n      TFormOnDynamic,\n      TFormOnDynamicAsync,\n      TFormOnServer,\n      TParentSubmitMeta\n    >,\n  ) => {\n    this.options = opts as never\n\n    const nameHasChanged = this.name !== opts.name\n    this.name = opts.name\n\n    // Default Value\n    if ((this.state.value as unknown) === undefined) {\n      const formDefault = getBy(opts.form.options.defaultValues, opts.name)\n\n      const defaultValue = (opts.defaultValue as unknown) ?? formDefault\n\n      // The name is dynamic in array fields. It changes when the user performs operations like removing or reordering.\n      // In this case, we don't want to force a default value if the store managed to find an existing value.\n      if (nameHasChanged) {\n        this.setValue((val) => (val as unknown) || defaultValue, {\n          dontUpdateMeta: true,\n        })\n      } else if (defaultValue !== undefined) {\n        this.setValue(defaultValue as never, {\n          dontUpdateMeta: true,\n        })\n      }\n    }\n\n    // Default Meta\n    if (this.form.getFieldMeta(this.name) === undefined) {\n      this.setMeta(this.state.meta)\n    }\n  }\n\n  /**\n   * Gets the current field value.\n   * @deprecated Use `field.state.value` instead.\n   */\n  getValue = (): TData => {\n    return this.form.getFieldValue(this.name) as TData\n  }\n\n  /**\n   * Sets the field value and run the `change` validator.\n   */\n  setValue = (updater: Updater<TData>, options?: UpdateMetaOptions) => {\n    this.form.setFieldValue(\n      this.name,\n      updater as never,\n      mergeOpts(options, { dontRunListeners: true, dontValidate: true }),\n    )\n\n    if (!options?.dontRunListeners) {\n      this.triggerOnChangeListener()\n    }\n\n    if (!options?.dontValidate) {\n      this.validate('change')\n    }\n  }\n\n  getMeta = () => this.store.state.meta\n\n  /**\n   * Sets the field metadata.\n   */\n  setMeta = (\n    updater: Updater<\n      FieldMetaBase<\n        TParentData,\n        TName,\n        TData,\n        TOnMount,\n        TOnChange,\n        TOnChangeAsync,\n        TOnBlur,\n        TOnBlurAsync,\n        TOnSubmit,\n        TOnSubmitAsync,\n        TOnDynamic,\n        TOnDynamicAsync,\n        TFormOnMount,\n        TFormOnChange,\n        TFormOnChangeAsync,\n        TFormOnBlur,\n        TFormOnBlurAsync,\n        TFormOnSubmit,\n        TFormOnSubmitAsync,\n        TFormOnDynamic,\n        TFormOnDynamicAsync\n      >\n    >,\n  ) => this.form.setFieldMeta(this.name, updater)\n\n  /**\n   * Gets the field information object.\n   */\n  getInfo = () => this.form.getFieldInfo(this.name)\n\n  /**\n   * Pushes a new value to the field.\n   */\n  pushValue = (\n    value: TData extends any[] ? TData[number] : never,\n    options?: UpdateMetaOptions,\n  ) => {\n    this.form.pushFieldValue(\n      this.name,\n      value as any,\n      mergeOpts(options, { dontRunListeners: true }),\n    )\n\n    if (!options?.dontRunListeners) {\n      this.triggerOnChangeListener()\n    }\n  }\n\n  /**\n   * Inserts a value at the specified index, shifting the subsequent values to the right.\n   */\n  insertValue = (\n    index: number,\n    value: TData extends any[] ? TData[number] : never,\n    options?: UpdateMetaOptions,\n  ) => {\n    this.form.insertFieldValue(\n      this.name,\n      index,\n      value as any,\n      mergeOpts(options, { dontRunListeners: true }),\n    )\n\n    if (!options?.dontRunListeners) {\n      this.triggerOnChangeListener()\n    }\n  }\n\n  /**\n   * Replaces a value at the specified index.\n   */\n  replaceValue = (\n    index: number,\n    value: TData extends any[] ? TData[number] : never,\n    options?: UpdateMetaOptions,\n  ) => {\n    this.form.replaceFieldValue(\n      this.name,\n      index,\n      value as any,\n      mergeOpts(options, { dontRunListeners: true }),\n    )\n\n    if (!options?.dontRunListeners) {\n      this.triggerOnChangeListener()\n    }\n  }\n\n  /**\n   * Removes a value at the specified index.\n   */\n  removeValue = (index: number, options?: UpdateMetaOptions) => {\n    this.form.removeFieldValue(\n      this.name,\n      index,\n      mergeOpts(options, { dontRunListeners: true }),\n    )\n\n    if (!options?.dontRunListeners) {\n      this.triggerOnChangeListener()\n    }\n  }\n\n  /**\n   * Swaps the values at the specified indices.\n   */\n  swapValues = (\n    aIndex: number,\n    bIndex: number,\n    options?: UpdateMetaOptions,\n  ) => {\n    this.form.swapFieldValues(\n      this.name,\n      aIndex,\n      bIndex,\n      mergeOpts(options, { dontRunListeners: true }),\n    )\n\n    if (!options?.dontRunListeners) {\n      this.triggerOnChangeListener()\n    }\n  }\n\n  /**\n   * Moves the value at the first specified index to the second specified index.\n   */\n  moveValue = (aIndex: number, bIndex: number, options?: UpdateMetaOptions) => {\n    this.form.moveFieldValues(\n      this.name,\n      aIndex,\n      bIndex,\n      mergeOpts(options, { dontRunListeners: true }),\n    )\n\n    if (!options?.dontRunListeners) {\n      this.triggerOnChangeListener()\n    }\n  }\n\n  /**\n   * Clear all values from the array.\n   */\n  clearValues = (options?: UpdateMetaOptions) => {\n    this.form.clearFieldValues(\n      this.name,\n      mergeOpts(options, { dontRunListeners: true }),\n    )\n\n    if (!options?.dontRunListeners) {\n      this.triggerOnChangeListener()\n    }\n  }\n\n  /**\n   * @private\n   */\n  getLinkedFields = (cause: ValidationCause) => {\n    const fields = Object.values(this.form.fieldInfo) as FieldInfo<any>[]\n\n    const linkedFields: AnyFieldApi[] = []\n    for (const field of fields) {\n      if (!field.instance) continue\n      const { onChangeListenTo, onBlurListenTo } =\n        field.instance.options.validators || {}\n      if (cause === 'change' && onChangeListenTo?.includes(this.name)) {\n        linkedFields.push(field.instance)\n      }\n      if (cause === 'blur' && onBlurListenTo?.includes(this.name as string)) {\n        linkedFields.push(field.instance)\n      }\n    }\n\n    return linkedFields\n  }\n\n  /**\n   * @private\n   */\n  validateSync = (\n    cause: ValidationCause,\n    errorFromForm: ValidationErrorMap,\n  ) => {\n    const validates = getSyncValidatorArray(cause, {\n      ...this.options,\n      form: this.form,\n      validationLogic:\n        this.form.options.validationLogic || defaultValidationLogic,\n    })\n\n    const linkedFields = this.getLinkedFields(cause)\n    const linkedFieldValidates = linkedFields.reduce(\n      (acc, field) => {\n        const fieldValidates = getSyncValidatorArray(cause, {\n          ...field.options,\n          form: field.form,\n          validationLogic:\n            field.form.options.validationLogic || defaultValidationLogic,\n        })\n        fieldValidates.forEach((validate) => {\n          ;(validate as any).field = field\n        })\n        return acc.concat(fieldValidates as never)\n      },\n      [] as Array<\n        SyncValidator<any> & {\n          field: AnyFieldApi\n        }\n      >,\n    )\n\n    // Needs type cast as eslint errantly believes this is always falsy\n    let hasErrored = false as boolean\n\n    batch(() => {\n      const validateFieldFn = (\n        field: AnyFieldApi,\n        validateObj: SyncValidator<any>,\n      ) => {\n        const errorMapKey = getErrorMapKey(validateObj.cause)\n\n        const fieldLevelError = validateObj.validate\n          ? normalizeError(\n              field.runValidator({\n                validate: validateObj.validate,\n                value: {\n                  value: field.store.state.value,\n                  validationSource: 'field',\n                  fieldApi: field,\n                },\n                type: 'validate',\n              }),\n            )\n          : undefined\n\n        const formLevelError = errorFromForm[errorMapKey]\n\n        const { newErrorValue, newSource } =\n          determineFieldLevelErrorSourceAndValue({\n            formLevelError,\n            fieldLevelError,\n          })\n\n        // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n        if (field.state.meta.errorMap?.[errorMapKey] !== newErrorValue) {\n          field.setMeta((prev) => ({\n            ...prev,\n            errorMap: {\n              ...prev.errorMap,\n              [errorMapKey]: newErrorValue,\n            },\n            errorSourceMap: {\n              ...prev.errorSourceMap,\n              [errorMapKey]: newSource,\n            },\n          }))\n        }\n        if (newErrorValue) {\n          hasErrored = true\n        }\n      }\n\n      for (const validateObj of validates) {\n        validateFieldFn(this, validateObj)\n      }\n      for (const fieldValitateObj of linkedFieldValidates) {\n        if (!fieldValitateObj.validate) continue\n        validateFieldFn(fieldValitateObj.field, fieldValitateObj)\n      }\n    })\n\n    /**\n     *  when we have an error for onSubmit in the state, we want\n     *  to clear the error as soon as the user enters a valid value in the field\n     */\n    const submitErrKey = getErrorMapKey('submit')\n\n    if (\n      // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n      this.state.meta.errorMap?.[submitErrKey] &&\n      cause !== 'submit' &&\n      !hasErrored\n    ) {\n      this.setMeta((prev) => ({\n        ...prev,\n        errorMap: {\n          ...prev.errorMap,\n          [submitErrKey]: undefined,\n        },\n        errorSourceMap: {\n          ...prev.errorSourceMap,\n          [submitErrKey]: undefined,\n        },\n      }))\n    }\n\n    return { hasErrored }\n  }\n\n  /**\n   * @private\n   */\n  validateAsync = async (\n    cause: ValidationCause,\n    formValidationResultPromise: Promise<\n      FieldErrorMapFromValidator<\n        TParentData,\n        TName,\n        TData,\n        TOnMount,\n        TOnChange,\n        TOnChangeAsync,\n        TOnBlur,\n        TOnBlurAsync,\n        TOnSubmit,\n        TOnSubmitAsync\n      >\n    >,\n  ) => {\n    const validates = getAsyncValidatorArray(cause, {\n      ...this.options,\n      form: this.form,\n      validationLogic:\n        this.form.options.validationLogic || defaultValidationLogic,\n    })\n\n    // Get the field-specific error messages that are coming from the form's validator\n    const asyncFormValidationResults = await formValidationResultPromise\n\n    const linkedFields = this.getLinkedFields(cause)\n    const linkedFieldValidates = linkedFields.reduce(\n      (acc, field) => {\n        const fieldValidates = getAsyncValidatorArray(cause, {\n          ...field.options,\n          form: field.form,\n          validationLogic:\n            field.form.options.validationLogic || defaultValidationLogic,\n        })\n        fieldValidates.forEach((validate) => {\n          ;(validate as any).field = field\n        })\n        return acc.concat(fieldValidates as never)\n      },\n      [] as Array<\n        AsyncValidator<any> & {\n          field: AnyFieldApi\n        }\n      >,\n    )\n\n    if (!this.state.meta.isValidating) {\n      this.setMeta((prev) => ({ ...prev, isValidating: true }))\n    }\n\n    for (const linkedField of linkedFields) {\n      linkedField.setMeta((prev) => ({ ...prev, isValidating: true }))\n    }\n\n    /**\n     * We have to use a for loop and generate our promises this way, otherwise it won't be sync\n     * when there are no validators needed to be run\n     */\n    const validatesPromises: Promise<ValidationError | undefined>[] = []\n    const linkedPromises: Promise<ValidationError | undefined>[] = []\n\n    const validateFieldAsyncFn = (\n      field: AnyFieldApi,\n      validateObj: AsyncValidator<any>,\n      promises: Promise<ValidationError | undefined>[],\n    ) => {\n      const errorMapKey = getErrorMapKey(validateObj.cause)\n      const fieldValidatorMeta = field.getInfo().validationMetaMap[errorMapKey]\n\n      fieldValidatorMeta?.lastAbortController.abort()\n      const controller = new AbortController()\n\n      this.getInfo().validationMetaMap[errorMapKey] = {\n        lastAbortController: controller,\n      }\n\n      promises.push(\n        new Promise<ValidationError | undefined>(async (resolve) => {\n          let rawError!: ValidationError | undefined\n          try {\n            rawError = await new Promise((rawResolve, rawReject) => {\n              if (this.timeoutIds.validations[validateObj.cause]) {\n                clearTimeout(this.timeoutIds.validations[validateObj.cause]!)\n              }\n\n              this.timeoutIds.validations[validateObj.cause] = setTimeout(\n                async () => {\n                  if (controller.signal.aborted) return rawResolve(undefined)\n                  try {\n                    rawResolve(\n                      await this.runValidator({\n                        validate: validateObj.validate,\n                        value: {\n                          value: field.store.state.value,\n                          fieldApi: field,\n                          signal: controller.signal,\n                          validationSource: 'field',\n                        },\n                        type: 'validateAsync',\n                      }),\n                    )\n                  } catch (e) {\n                    rawReject(e)\n                  }\n                },\n                validateObj.debounceMs,\n              )\n            })\n          } catch (e: unknown) {\n            rawError = e as ValidationError\n          }\n          if (controller.signal.aborted) return resolve(undefined)\n\n          const fieldLevelError = normalizeError(rawError)\n          const formLevelError =\n            asyncFormValidationResults[this.name]?.[errorMapKey]\n\n          const { newErrorValue, newSource } =\n            determineFieldLevelErrorSourceAndValue({\n              formLevelError,\n              fieldLevelError,\n            })\n\n          field.setMeta((prev) => {\n            return {\n              ...prev,\n              errorMap: {\n                // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n                ...prev?.errorMap,\n                [errorMapKey]: newErrorValue,\n              },\n              errorSourceMap: {\n                ...prev.errorSourceMap,\n                [errorMapKey]: newSource,\n              },\n            }\n          })\n\n          resolve(newErrorValue)\n        }),\n      )\n    }\n\n    // TODO: Dedupe this logic to reduce bundle size\n    for (const validateObj of validates) {\n      if (!validateObj.validate) continue\n      validateFieldAsyncFn(this, validateObj, validatesPromises)\n    }\n    for (const fieldValitateObj of linkedFieldValidates) {\n      if (!fieldValitateObj.validate) continue\n      validateFieldAsyncFn(\n        fieldValitateObj.field,\n        fieldValitateObj,\n        linkedPromises,\n      )\n    }\n\n    let results: ValidationError[] = []\n    if (validatesPromises.length || linkedPromises.length) {\n      results = await Promise.all(validatesPromises)\n      await Promise.all(linkedPromises)\n    }\n\n    this.setMeta((prev) => ({ ...prev, isValidating: false }))\n\n    for (const linkedField of linkedFields) {\n      linkedField.setMeta((prev) => ({ ...prev, isValidating: false }))\n    }\n\n    return results.filter(Boolean)\n  }\n\n  /**\n   * Validates the field value.\n   */\n  validate = (\n    cause: ValidationCause,\n    opts?: { skipFormValidation?: boolean },\n  ): ValidationError[] | Promise<ValidationError[]> => {\n    // If the field is pristine, do not validate\n    if (!this.state.meta.isTouched) return []\n\n    // Attempt to sync validate first\n    const { fieldsErrorMap } = opts?.skipFormValidation\n      ? { fieldsErrorMap: {} as never }\n      : this.form.validateSync(cause)\n    const { hasErrored } = this.validateSync(\n      cause,\n      fieldsErrorMap[this.name] ?? {},\n    )\n\n    if (hasErrored && !this.options.asyncAlways) {\n      this.getInfo().validationMetaMap[\n        getErrorMapKey(cause)\n      ]?.lastAbortController.abort()\n      return this.state.meta.errors\n    }\n\n    // No error? Attempt async validation\n    const formValidationResultPromise = opts?.skipFormValidation\n      ? Promise.resolve({})\n      : this.form.validateAsync(cause)\n    return this.validateAsync(cause, formValidationResultPromise)\n  }\n\n  /**\n   * Handles the change event.\n   */\n  handleChange = (updater: Updater<TData>) => {\n    this.setValue(updater)\n  }\n\n  /**\n   * Handles the blur event.\n   */\n  handleBlur = () => {\n    const prevTouched = this.state.meta.isTouched\n    if (!prevTouched) {\n      this.setMeta((prev) => ({ ...prev, isTouched: true }))\n    }\n    if (!this.state.meta.isBlurred) {\n      this.setMeta((prev) => ({ ...prev, isBlurred: true }))\n    }\n    this.validate('blur')\n\n    this.triggerOnBlurListener()\n  }\n\n  /**\n   * Updates the field's errorMap\n   */\n  setErrorMap(\n    errorMap: ValidationErrorMap<\n      UnwrapFieldValidateOrFn<TName, TOnMount, TFormOnMount>,\n      UnwrapFieldValidateOrFn<TName, TOnChange, TFormOnChange>,\n      UnwrapFieldAsyncValidateOrFn<TName, TOnChangeAsync, TFormOnChangeAsync>,\n      UnwrapFieldValidateOrFn<TName, TOnBlur, TFormOnBlur>,\n      UnwrapFieldAsyncValidateOrFn<TName, TOnBlurAsync, TFormOnBlurAsync>,\n      UnwrapFieldValidateOrFn<TName, TOnSubmit, TFormOnSubmit>,\n      UnwrapFieldAsyncValidateOrFn<TName, TOnSubmitAsync, TFormOnSubmitAsync>,\n      UnwrapFieldValidateOrFn<TName, TOnDynamic, TFormOnDynamic>,\n      UnwrapFieldAsyncValidateOrFn<TName, TOnDynamicAsync, TFormOnDynamicAsync>\n    >,\n  ) {\n    this.setMeta((prev) => ({\n      ...prev,\n      errorMap: {\n        ...prev.errorMap,\n        ...errorMap,\n      },\n    }))\n  }\n\n  /**\n   * Parses the field's value with the given schema and returns\n   * issues (if any). This method does NOT set any internal errors.\n   * @param schema The standard schema to parse this field's value with.\n   */\n  parseValueWithSchema = (schema: StandardSchemaV1<TData, unknown>) => {\n    return standardSchemaValidators.validate(\n      { value: this.state.value, validationSource: 'field' },\n      schema,\n    )\n  }\n\n  /**\n   * Parses the field's value with the given schema and returns\n   * issues (if any). This method does NOT set any internal errors.\n   * @param schema The standard schema to parse this field's value with.\n   */\n  parseValueWithSchemaAsync = (schema: StandardSchemaV1<TData, unknown>) => {\n    return standardSchemaValidators.validateAsync(\n      { value: this.state.value, validationSource: 'field' },\n      schema,\n    )\n  }\n\n  private triggerOnBlurListener() {\n    const formDebounceMs = this.form.options.listeners?.onBlurDebounceMs\n    if (formDebounceMs && formDebounceMs > 0) {\n      if (this.timeoutIds.formListeners.blur) {\n        clearTimeout(this.timeoutIds.formListeners.blur)\n      }\n\n      this.timeoutIds.formListeners.blur = setTimeout(() => {\n        this.form.options.listeners?.onBlur?.({\n          formApi: this.form,\n          fieldApi: this,\n        })\n      }, formDebounceMs)\n    } else {\n      this.form.options.listeners?.onBlur?.({\n        formApi: this.form,\n        fieldApi: this,\n      })\n    }\n\n    const fieldDebounceMs = this.options.listeners?.onBlurDebounceMs\n    if (fieldDebounceMs && fieldDebounceMs > 0) {\n      if (this.timeoutIds.listeners.blur) {\n        clearTimeout(this.timeoutIds.listeners.blur)\n      }\n\n      this.timeoutIds.listeners.blur = setTimeout(() => {\n        this.options.listeners?.onBlur?.({\n          value: this.state.value,\n          fieldApi: this,\n        })\n      }, fieldDebounceMs)\n    } else {\n      this.options.listeners?.onBlur?.({\n        value: this.state.value,\n        fieldApi: this,\n      })\n    }\n  }\n\n  /**\n   * @private\n   */\n  triggerOnChangeListener() {\n    const formDebounceMs = this.form.options.listeners?.onChangeDebounceMs\n    if (formDebounceMs && formDebounceMs > 0) {\n      if (this.timeoutIds.formListeners.change) {\n        clearTimeout(this.timeoutIds.formListeners.change)\n      }\n\n      this.timeoutIds.formListeners.change = setTimeout(() => {\n        this.form.options.listeners?.onChange?.({\n          formApi: this.form,\n          fieldApi: this,\n        })\n      }, formDebounceMs)\n    } else {\n      this.form.options.listeners?.onChange?.({\n        formApi: this.form,\n        fieldApi: this,\n      })\n    }\n\n    const fieldDebounceMs = this.options.listeners?.onChangeDebounceMs\n    if (fieldDebounceMs && fieldDebounceMs > 0) {\n      if (this.timeoutIds.listeners.change) {\n        clearTimeout(this.timeoutIds.listeners.change)\n      }\n\n      this.timeoutIds.listeners.change = setTimeout(() => {\n        this.options.listeners?.onChange?.({\n          value: this.state.value,\n          fieldApi: this,\n        })\n      }, fieldDebounceMs)\n    } else {\n      this.options.listeners?.onChange?.({\n        value: this.state.value,\n        fieldApi: this,\n      })\n    }\n  }\n}\n\nfunction normalizeError(rawError?: ValidationError) {\n  if (rawError) {\n    return rawError\n  }\n\n  return undefined\n}\n\nfunction getErrorMapKey(cause: ValidationCause) {\n  switch (cause) {\n    case 'submit':\n      return 'onSubmit'\n    case 'blur':\n      return 'onBlur'\n    case 'mount':\n      return 'onMount'\n    case 'server':\n      return 'onServer'\n    case 'dynamic':\n      return 'onDynamic'\n    case 'change':\n    default:\n      return 'onChange'\n  }\n}\n"],"names":["opts"],"mappings":"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","debugId":null}}]
}